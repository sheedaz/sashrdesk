// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `message.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

// @@protoc_insertion_point(message:hbb.EncodedVideoFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EncodedVideoFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.data)
    pub data: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.key)
    pub key: bool,
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.pts)
    pub pts: i64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.EncodedVideoFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncodedVideoFrame {
    fn default() -> &'a EncodedVideoFrame {
        <EncodedVideoFrame as ::protobuf::Message>::default_instance()
    }
}

impl EncodedVideoFrame {
    pub fn new() -> EncodedVideoFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &EncodedVideoFrame| { &m.data },
            |m: &mut EncodedVideoFrame| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &EncodedVideoFrame| { &m.key },
            |m: &mut EncodedVideoFrame| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pts",
            |m: &EncodedVideoFrame| { &m.pts },
            |m: &mut EncodedVideoFrame| { &mut m.pts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncodedVideoFrame>(
            "EncodedVideoFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncodedVideoFrame {
    const NAME: &'static str = "EncodedVideoFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_tokio_bytes()?;
                },
                16 => {
                    self.key = is.read_bool()?;
                },
                24 => {
                    self.pts = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.key != false {
            my_size += 1 + 1;
        }
        if self.pts != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.pts);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.key != false {
            os.write_bool(2, self.key)?;
        }
        if self.pts != 0 {
            os.write_int64(3, self.pts)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncodedVideoFrame {
        EncodedVideoFrame::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.key = false;
        self.pts = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncodedVideoFrame {
        static instance: EncodedVideoFrame = EncodedVideoFrame {
            data: ::bytes::Bytes::new(),
            key: false,
            pts: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncodedVideoFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncodedVideoFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncodedVideoFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncodedVideoFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.EncodedVideoFrames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EncodedVideoFrames {
    // message fields
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrames.frames)
    pub frames: ::std::vec::Vec<EncodedVideoFrame>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.EncodedVideoFrames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncodedVideoFrames {
    fn default() -> &'a EncodedVideoFrames {
        <EncodedVideoFrames as ::protobuf::Message>::default_instance()
    }
}

impl EncodedVideoFrames {
    pub fn new() -> EncodedVideoFrames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frames",
            |m: &EncodedVideoFrames| { &m.frames },
            |m: &mut EncodedVideoFrames| { &mut m.frames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncodedVideoFrames>(
            "EncodedVideoFrames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncodedVideoFrames {
    const NAME: &'static str = "EncodedVideoFrames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.frames.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncodedVideoFrames {
        EncodedVideoFrames::new()
    }

    fn clear(&mut self) {
        self.frames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncodedVideoFrames {
        static instance: EncodedVideoFrames = EncodedVideoFrames {
            frames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncodedVideoFrames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncodedVideoFrames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncodedVideoFrames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncodedVideoFrames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.RGB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RGB {
    // message fields
    // @@protoc_insertion_point(field:hbb.RGB.compress)
    pub compress: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.RGB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RGB {
    fn default() -> &'a RGB {
        <RGB as ::protobuf::Message>::default_instance()
    }
}

impl RGB {
    pub fn new() -> RGB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &RGB| { &m.compress },
            |m: &mut RGB| { &mut m.compress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RGB>(
            "RGB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RGB {
    const NAME: &'static str = "RGB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RGB {
        RGB::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RGB {
        static instance: RGB = RGB {
            compress: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RGB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RGB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RGB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RGB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.YUV)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct YUV {
    // message fields
    // @@protoc_insertion_point(field:hbb.YUV.compress)
    pub compress: bool,
    // @@protoc_insertion_point(field:hbb.YUV.stride)
    pub stride: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.YUV.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a YUV {
    fn default() -> &'a YUV {
        <YUV as ::protobuf::Message>::default_instance()
    }
}

impl YUV {
    pub fn new() -> YUV {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &YUV| { &m.compress },
            |m: &mut YUV| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stride",
            |m: &YUV| { &m.stride },
            |m: &mut YUV| { &mut m.stride },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<YUV>(
            "YUV",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for YUV {
    const NAME: &'static str = "YUV";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                16 => {
                    self.stride = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        if self.stride != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.stride);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if self.stride != 0 {
            os.write_int32(2, self.stride)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> YUV {
        YUV::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.stride = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static YUV {
        static instance: YUV = YUV {
            compress: false,
            stride: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for YUV {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("YUV").unwrap()).clone()
    }
}

impl ::std::fmt::Display for YUV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for YUV {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.VideoFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.VideoFrame.display)
    pub display: i32,
    // message oneof groups
    pub union: ::std::option::Option<video_frame::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.VideoFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFrame {
    fn default() -> &'a VideoFrame {
        <VideoFrame as ::protobuf::Message>::default_instance()
    }
}

impl VideoFrame {
    pub fn new() -> VideoFrame {
        ::std::default::Default::default()
    }

    // .hbb.EncodedVideoFrames vp9s = 6;

    pub fn vp9s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vp9s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_vp9s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vp9s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vp9s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::Vp9s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vp9s(&mut self) -> EncodedVideoFrames {
        if self.has_vp9s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Vp9s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.RGB rgb = 7;

    pub fn rgb(&self) -> &RGB {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(ref v)) => v,
            _ => <RGB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rgb(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_rgb(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rgb(&mut self, v: RGB) {
        self.union = ::std::option::Option::Some(video_frame::Union::Rgb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rgb(&mut self) -> &mut RGB {
        if let ::std::option::Option::Some(video_frame::Union::Rgb(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Rgb(RGB::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rgb(&mut self) -> RGB {
        if self.has_rgb() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Rgb(v)) => v,
                _ => panic!(),
            }
        } else {
            RGB::new()
        }
    }

    // .hbb.YUV yuv = 8;

    pub fn yuv(&self) -> &YUV {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(ref v)) => v,
            _ => <YUV as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_yuv(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_yuv(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_yuv(&mut self, v: YUV) {
        self.union = ::std::option::Option::Some(video_frame::Union::Yuv(v))
    }

    // Mutable pointer to the field.
    pub fn mut_yuv(&mut self) -> &mut YUV {
        if let ::std::option::Option::Some(video_frame::Union::Yuv(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Yuv(YUV::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_yuv(&mut self) -> YUV {
        if self.has_yuv() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Yuv(v)) => v,
                _ => panic!(),
            }
        } else {
            YUV::new()
        }
    }

    // .hbb.EncodedVideoFrames h264s = 10;

    pub fn h264s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_h264s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_h264s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_h264s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::H264s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_h264s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::H264s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::H264s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_h264s(&mut self) -> EncodedVideoFrames {
        if self.has_h264s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::H264s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.EncodedVideoFrames h265s = 11;

    pub fn h265s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_h265s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_h265s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_h265s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::H265s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_h265s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::H265s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::H265s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_h265s(&mut self) -> EncodedVideoFrames {
        if self.has_h265s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::H265s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.EncodedVideoFrames vp8s = 12;

    pub fn vp8s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp8s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vp8s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_vp8s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp8s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vp8s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::Vp8s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vp8s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::Vp8s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Vp8s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp8s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vp8s(&mut self) -> EncodedVideoFrames {
        if self.has_vp8s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Vp8s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.EncodedVideoFrames av1s = 13;

    pub fn av1s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Av1s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_av1s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_av1s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Av1s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_av1s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::Av1s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_av1s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::Av1s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Av1s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Av1s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_av1s(&mut self) -> EncodedVideoFrames {
        if self.has_av1s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Av1s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "vp9s",
            VideoFrame::has_vp9s,
            VideoFrame::vp9s,
            VideoFrame::mut_vp9s,
            VideoFrame::set_vp9s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RGB>(
            "rgb",
            VideoFrame::has_rgb,
            VideoFrame::rgb,
            VideoFrame::mut_rgb,
            VideoFrame::set_rgb,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, YUV>(
            "yuv",
            VideoFrame::has_yuv,
            VideoFrame::yuv,
            VideoFrame::mut_yuv,
            VideoFrame::set_yuv,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "h264s",
            VideoFrame::has_h264s,
            VideoFrame::h264s,
            VideoFrame::mut_h264s,
            VideoFrame::set_h264s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "h265s",
            VideoFrame::has_h265s,
            VideoFrame::h265s,
            VideoFrame::mut_h265s,
            VideoFrame::set_h265s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "vp8s",
            VideoFrame::has_vp8s,
            VideoFrame::vp8s,
            VideoFrame::mut_vp8s,
            VideoFrame::set_vp8s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "av1s",
            VideoFrame::has_av1s,
            VideoFrame::av1s,
            VideoFrame::mut_av1s,
            VideoFrame::set_av1s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &VideoFrame| { &m.display },
            |m: &mut VideoFrame| { &mut m.display },
        ));
        oneofs.push(video_frame::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFrame>(
            "VideoFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFrame {
    const NAME: &'static str = "VideoFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Rgb(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Yuv(is.read_message()?));
                },
                82 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::H264s(is.read_message()?));
                },
                90 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::H265s(is.read_message()?));
                },
                98 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Vp8s(is.read_message()?));
                },
                106 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Av1s(is.read_message()?));
                },
                112 => {
                    self.display = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.display);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::Vp9s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Rgb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Yuv(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::H264s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::H265s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Vp8s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Av1s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.display != 0 {
            os.write_int32(14, self.display)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::Vp9s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &video_frame::Union::Rgb(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &video_frame::Union::Yuv(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &video_frame::Union::H264s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &video_frame::Union::H265s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &video_frame::Union::Vp8s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &video_frame::Union::Av1s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFrame {
        VideoFrame::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.display = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFrame {
        static instance: VideoFrame = VideoFrame {
            display: 0,
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoFrame`
pub mod video_frame {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.VideoFrame.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.vp9s)
        Vp9s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.rgb)
        Rgb(super::RGB),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.yuv)
        Yuv(super::YUV),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.h264s)
        H264s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.h265s)
        H265s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.vp8s)
        Vp8s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.av1s)
        Av1s(super::EncodedVideoFrames),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::VideoFrame as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.IdPk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IdPk {
    // message fields
    // @@protoc_insertion_point(field:hbb.IdPk.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.IdPk.pk)
    pub pk: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.IdPk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdPk {
    fn default() -> &'a IdPk {
        <IdPk as ::protobuf::Message>::default_instance()
    }
}

impl IdPk {
    pub fn new() -> IdPk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IdPk| { &m.id },
            |m: &mut IdPk| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pk",
            |m: &IdPk| { &m.pk },
            |m: &mut IdPk| { &mut m.pk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdPk>(
            "IdPk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdPk {
    const NAME: &'static str = "IdPk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.pk = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.pk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.pk.is_empty() {
            os.write_bytes(2, &self.pk)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdPk {
        IdPk::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.pk.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdPk {
        static instance: IdPk = IdPk {
            id: ::std::string::String::new(),
            pk: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdPk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdPk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdPk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdPk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.DisplayInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisplayInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.DisplayInfo.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.online)
    pub online: bool,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.cursor_embedded)
    pub cursor_embedded: bool,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.original_resolution)
    pub original_resolution: ::protobuf::MessageField<Resolution>,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.scale)
    pub scale: f64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.DisplayInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayInfo {
    fn default() -> &'a DisplayInfo {
        <DisplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl DisplayInfo {
    pub fn new() -> DisplayInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &DisplayInfo| { &m.x },
            |m: &mut DisplayInfo| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &DisplayInfo| { &m.y },
            |m: &mut DisplayInfo| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &DisplayInfo| { &m.width },
            |m: &mut DisplayInfo| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &DisplayInfo| { &m.height },
            |m: &mut DisplayInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DisplayInfo| { &m.name },
            |m: &mut DisplayInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "online",
            |m: &DisplayInfo| { &m.online },
            |m: &mut DisplayInfo| { &mut m.online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor_embedded",
            |m: &DisplayInfo| { &m.cursor_embedded },
            |m: &mut DisplayInfo| { &mut m.cursor_embedded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Resolution>(
            "original_resolution",
            |m: &DisplayInfo| { &m.original_resolution },
            |m: &mut DisplayInfo| { &mut m.original_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale",
            |m: &DisplayInfo| { &m.scale },
            |m: &mut DisplayInfo| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayInfo>(
            "DisplayInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayInfo {
    const NAME: &'static str = "DisplayInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_sint32()?;
                },
                16 => {
                    self.y = is.read_sint32()?;
                },
                24 => {
                    self.width = is.read_int32()?;
                },
                32 => {
                    self.height = is.read_int32()?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                48 => {
                    self.online = is.read_bool()?;
                },
                56 => {
                    self.cursor_embedded = is.read_bool()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_resolution)?;
                },
                73 => {
                    self.scale = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.height);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.online != false {
            my_size += 1 + 1;
        }
        if self.cursor_embedded != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.original_resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.scale != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.online != false {
            os.write_bool(6, self.online)?;
        }
        if self.cursor_embedded != false {
            os.write_bool(7, self.cursor_embedded)?;
        }
        if let Some(v) = self.original_resolution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.scale != 0. {
            os.write_double(9, self.scale)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayInfo {
        DisplayInfo::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.name.clear();
        self.online = false;
        self.cursor_embedded = false;
        self.original_resolution.clear();
        self.scale = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayInfo {
        static instance: DisplayInfo = DisplayInfo {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            name: ::std::string::String::new(),
            online: false,
            cursor_embedded: false,
            original_resolution: ::protobuf::MessageField::none(),
            scale: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PortForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortForward {
    // message fields
    // @@protoc_insertion_point(field:hbb.PortForward.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PortForward.port)
    pub port: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PortForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortForward {
    fn default() -> &'a PortForward {
        <PortForward as ::protobuf::Message>::default_instance()
    }
}

impl PortForward {
    pub fn new() -> PortForward {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &PortForward| { &m.host },
            |m: &mut PortForward| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &PortForward| { &m.port },
            |m: &mut PortForward| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortForward>(
            "PortForward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortForward {
    const NAME: &'static str = "PortForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_string()?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortForward {
        PortForward::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortForward {
        static instance: PortForward = PortForward {
            host: ::std::string::String::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortForward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortForward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransfer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransfer {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransfer.dir)
    pub dir: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransfer.show_hidden)
    pub show_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransfer {
    fn default() -> &'a FileTransfer {
        <FileTransfer as ::protobuf::Message>::default_instance()
    }
}

impl FileTransfer {
    pub fn new() -> FileTransfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir",
            |m: &FileTransfer| { &m.dir },
            |m: &mut FileTransfer| { &mut m.dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_hidden",
            |m: &FileTransfer| { &m.show_hidden },
            |m: &mut FileTransfer| { &mut m.show_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransfer>(
            "FileTransfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransfer {
    const NAME: &'static str = "FileTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dir = is.read_string()?;
                },
                16 => {
                    self.show_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dir);
        }
        if self.show_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dir.is_empty() {
            os.write_string(1, &self.dir)?;
        }
        if self.show_hidden != false {
            os.write_bool(2, self.show_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransfer {
        FileTransfer::new()
    }

    fn clear(&mut self) {
        self.dir.clear();
        self.show_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransfer {
        static instance: FileTransfer = FileTransfer {
            dir: ::std::string::String::new(),
            show_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.OSLogin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OSLogin {
    // message fields
    // @@protoc_insertion_point(field:hbb.OSLogin.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.OSLogin.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.OSLogin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OSLogin {
    fn default() -> &'a OSLogin {
        <OSLogin as ::protobuf::Message>::default_instance()
    }
}

impl OSLogin {
    pub fn new() -> OSLogin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &OSLogin| { &m.username },
            |m: &mut OSLogin| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &OSLogin| { &m.password },
            |m: &mut OSLogin| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OSLogin>(
            "OSLogin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OSLogin {
    const NAME: &'static str = "OSLogin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OSLogin {
        OSLogin::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OSLogin {
        static instance: OSLogin = OSLogin {
            username: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OSLogin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OSLogin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OSLogin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSLogin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.LoginRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.LoginRequest.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.password)
    pub password: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.LoginRequest.my_id)
    pub my_id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.my_name)
    pub my_name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.option)
    pub option: ::protobuf::MessageField<OptionMessage>,
    // @@protoc_insertion_point(field:hbb.LoginRequest.video_ack_required)
    pub video_ack_required: bool,
    // @@protoc_insertion_point(field:hbb.LoginRequest.session_id)
    pub session_id: u64,
    // @@protoc_insertion_point(field:hbb.LoginRequest.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.os_login)
    pub os_login: ::protobuf::MessageField<OSLogin>,
    // message oneof groups
    pub union: ::std::option::Option<login_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.LoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // .hbb.FileTransfer file_transfer = 7;

    pub fn file_transfer(&self) -> &FileTransfer {
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(ref v)) => v,
            _ => <FileTransfer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_transfer(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_transfer(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_transfer(&mut self, v: FileTransfer) {
        self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_transfer(&mut self) -> &mut FileTransfer {
        if let ::std::option::Option::Some(login_request::Union::FileTransfer(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(FileTransfer::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_transfer(&mut self) -> FileTransfer {
        if self.has_file_transfer() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::FileTransfer(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransfer::new()
        }
    }

    // .hbb.PortForward port_forward = 8;

    pub fn port_forward(&self) -> &PortForward {
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(ref v)) => v,
            _ => <PortForward as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_port_forward(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_port_forward(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_port_forward(&mut self, v: PortForward) {
        self.union = ::std::option::Option::Some(login_request::Union::PortForward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_port_forward(&mut self) -> &mut PortForward {
        if let ::std::option::Option::Some(login_request::Union::PortForward(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::PortForward(PortForward::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_port_forward(&mut self) -> PortForward {
        if self.has_port_forward() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::PortForward(v)) => v,
                _ => panic!(),
            }
        } else {
            PortForward::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &LoginRequest| { &m.username },
            |m: &mut LoginRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &LoginRequest| { &m.password },
            |m: &mut LoginRequest| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_id",
            |m: &LoginRequest| { &m.my_id },
            |m: &mut LoginRequest| { &mut m.my_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_name",
            |m: &LoginRequest| { &m.my_name },
            |m: &mut LoginRequest| { &mut m.my_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OptionMessage>(
            "option",
            |m: &LoginRequest| { &m.option },
            |m: &mut LoginRequest| { &mut m.option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransfer>(
            "file_transfer",
            LoginRequest::has_file_transfer,
            LoginRequest::file_transfer,
            LoginRequest::mut_file_transfer,
            LoginRequest::set_file_transfer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PortForward>(
            "port_forward",
            LoginRequest::has_port_forward,
            LoginRequest::port_forward,
            LoginRequest::mut_port_forward,
            LoginRequest::set_port_forward,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video_ack_required",
            |m: &LoginRequest| { &m.video_ack_required },
            |m: &mut LoginRequest| { &mut m.video_ack_required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &LoginRequest| { &m.session_id },
            |m: &mut LoginRequest| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &LoginRequest| { &m.version },
            |m: &mut LoginRequest| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OSLogin>(
            "os_login",
            |m: &LoginRequest| { &m.os_login },
            |m: &mut LoginRequest| { &mut m.os_login },
        ));
        oneofs.push(login_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginRequest>(
            "LoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginRequest {
    const NAME: &'static str = "LoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.password = is.read_tokio_bytes()?;
                },
                34 => {
                    self.my_id = is.read_string()?;
                },
                42 => {
                    self.my_name = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                58 => {
                    self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(login_request::Union::PortForward(is.read_message()?));
                },
                72 => {
                    self.video_ack_required = is.read_bool()?;
                },
                80 => {
                    self.session_id = is.read_uint64()?;
                },
                90 => {
                    self.version = is.read_string()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.os_login)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.password);
        }
        if !self.my_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.my_id);
        }
        if !self.my_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.my_name);
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.video_ack_required != false {
            my_size += 1 + 1;
        }
        if self.session_id != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.session_id);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.version);
        }
        if let Some(v) = self.os_login.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::FileTransfer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Union::PortForward(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_bytes(2, &self.password)?;
        }
        if !self.my_id.is_empty() {
            os.write_string(4, &self.my_id)?;
        }
        if !self.my_name.is_empty() {
            os.write_string(5, &self.my_name)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.video_ack_required != false {
            os.write_bool(9, self.video_ack_required)?;
        }
        if self.session_id != 0 {
            os.write_uint64(10, self.session_id)?;
        }
        if !self.version.is_empty() {
            os.write_string(11, &self.version)?;
        }
        if let Some(v) = self.os_login.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::FileTransfer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &login_request::Union::PortForward(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.my_id.clear();
        self.my_name.clear();
        self.option.clear();
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.video_ack_required = false;
        self.session_id = 0;
        self.version.clear();
        self.os_login.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginRequest {
        static instance: LoginRequest = LoginRequest {
            username: ::std::string::String::new(),
            password: ::bytes::Bytes::new(),
            my_id: ::std::string::String::new(),
            my_name: ::std::string::String::new(),
            option: ::protobuf::MessageField::none(),
            video_ack_required: false,
            session_id: 0,
            version: ::std::string::String::new(),
            os_login: ::protobuf::MessageField::none(),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginRequest`
pub mod login_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.LoginRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.LoginRequest.file_transfer)
        FileTransfer(super::FileTransfer),
        // @@protoc_insertion_point(oneof_field:hbb.LoginRequest.port_forward)
        PortForward(super::PortForward),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.Auth2FA)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Auth2FA {
    // message fields
    // @@protoc_insertion_point(field:hbb.Auth2FA.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Auth2FA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Auth2FA {
    fn default() -> &'a Auth2FA {
        <Auth2FA as ::protobuf::Message>::default_instance()
    }
}

impl Auth2FA {
    pub fn new() -> Auth2FA {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Auth2FA| { &m.code },
            |m: &mut Auth2FA| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Auth2FA>(
            "Auth2FA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Auth2FA {
    const NAME: &'static str = "Auth2FA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Auth2FA {
        Auth2FA::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Auth2FA {
        static instance: Auth2FA = Auth2FA {
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Auth2FA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Auth2FA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Auth2FA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Auth2FA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:hbb.ChatMessage.text)
    pub text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatMessage {
    fn default() -> &'a ChatMessage {
        <ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessage {
    pub fn new() -> ChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &ChatMessage| { &m.text },
            |m: &mut ChatMessage| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
            "ChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatMessage {
    const NAME: &'static str = "ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatMessage {
        ChatMessage::new()
    }

    fn clear(&mut self) {
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatMessage {
        static instance: ChatMessage = ChatMessage {
            text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Features)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Features {
    // message fields
    // @@protoc_insertion_point(field:hbb.Features.privacy_mode)
    pub privacy_mode: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Features.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Features {
    fn default() -> &'a Features {
        <Features as ::protobuf::Message>::default_instance()
    }
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privacy_mode",
            |m: &Features| { &m.privacy_mode },
            |m: &mut Features| { &mut m.privacy_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Features>(
            "Features",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Features {
    const NAME: &'static str = "Features";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.privacy_mode = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.privacy_mode != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.privacy_mode != false {
            os.write_bool(1, self.privacy_mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Features {
        Features::new()
    }

    fn clear(&mut self) {
        self.privacy_mode = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Features {
        static instance: Features = Features {
            privacy_mode: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Features {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Features").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CodecAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodecAbility {
    // message fields
    // @@protoc_insertion_point(field:hbb.CodecAbility.vp8)
    pub vp8: bool,
    // @@protoc_insertion_point(field:hbb.CodecAbility.vp9)
    pub vp9: bool,
    // @@protoc_insertion_point(field:hbb.CodecAbility.av1)
    pub av1: bool,
    // @@protoc_insertion_point(field:hbb.CodecAbility.h264)
    pub h264: bool,
    // @@protoc_insertion_point(field:hbb.CodecAbility.h265)
    pub h265: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CodecAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodecAbility {
    fn default() -> &'a CodecAbility {
        <CodecAbility as ::protobuf::Message>::default_instance()
    }
}

impl CodecAbility {
    pub fn new() -> CodecAbility {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vp8",
            |m: &CodecAbility| { &m.vp8 },
            |m: &mut CodecAbility| { &mut m.vp8 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vp9",
            |m: &CodecAbility| { &m.vp9 },
            |m: &mut CodecAbility| { &mut m.vp9 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "av1",
            |m: &CodecAbility| { &m.av1 },
            |m: &mut CodecAbility| { &mut m.av1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h264",
            |m: &CodecAbility| { &m.h264 },
            |m: &mut CodecAbility| { &mut m.h264 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h265",
            |m: &CodecAbility| { &m.h265 },
            |m: &mut CodecAbility| { &mut m.h265 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodecAbility>(
            "CodecAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodecAbility {
    const NAME: &'static str = "CodecAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.vp8 = is.read_bool()?;
                },
                16 => {
                    self.vp9 = is.read_bool()?;
                },
                24 => {
                    self.av1 = is.read_bool()?;
                },
                32 => {
                    self.h264 = is.read_bool()?;
                },
                40 => {
                    self.h265 = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.vp8 != false {
            my_size += 1 + 1;
        }
        if self.vp9 != false {
            my_size += 1 + 1;
        }
        if self.av1 != false {
            my_size += 1 + 1;
        }
        if self.h264 != false {
            my_size += 1 + 1;
        }
        if self.h265 != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.vp8 != false {
            os.write_bool(1, self.vp8)?;
        }
        if self.vp9 != false {
            os.write_bool(2, self.vp9)?;
        }
        if self.av1 != false {
            os.write_bool(3, self.av1)?;
        }
        if self.h264 != false {
            os.write_bool(4, self.h264)?;
        }
        if self.h265 != false {
            os.write_bool(5, self.h265)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodecAbility {
        CodecAbility::new()
    }

    fn clear(&mut self) {
        self.vp8 = false;
        self.vp9 = false;
        self.av1 = false;
        self.h264 = false;
        self.h265 = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodecAbility {
        static instance: CodecAbility = CodecAbility {
            vp8: false,
            vp9: false,
            av1: false,
            h264: false,
            h265: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodecAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodecAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodecAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodecAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SupportedEncoding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SupportedEncoding {
    // message fields
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.h264)
    pub h264: bool,
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.h265)
    pub h265: bool,
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.vp8)
    pub vp8: bool,
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.av1)
    pub av1: bool,
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.i444)
    pub i444: ::protobuf::MessageField<CodecAbility>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SupportedEncoding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SupportedEncoding {
    fn default() -> &'a SupportedEncoding {
        <SupportedEncoding as ::protobuf::Message>::default_instance()
    }
}

impl SupportedEncoding {
    pub fn new() -> SupportedEncoding {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h264",
            |m: &SupportedEncoding| { &m.h264 },
            |m: &mut SupportedEncoding| { &mut m.h264 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h265",
            |m: &SupportedEncoding| { &m.h265 },
            |m: &mut SupportedEncoding| { &mut m.h265 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vp8",
            |m: &SupportedEncoding| { &m.vp8 },
            |m: &mut SupportedEncoding| { &mut m.vp8 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "av1",
            |m: &SupportedEncoding| { &m.av1 },
            |m: &mut SupportedEncoding| { &mut m.av1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CodecAbility>(
            "i444",
            |m: &SupportedEncoding| { &m.i444 },
            |m: &mut SupportedEncoding| { &mut m.i444 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SupportedEncoding>(
            "SupportedEncoding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SupportedEncoding {
    const NAME: &'static str = "SupportedEncoding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.h264 = is.read_bool()?;
                },
                16 => {
                    self.h265 = is.read_bool()?;
                },
                24 => {
                    self.vp8 = is.read_bool()?;
                },
                32 => {
                    self.av1 = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.i444)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.h264 != false {
            my_size += 1 + 1;
        }
        if self.h265 != false {
            my_size += 1 + 1;
        }
        if self.vp8 != false {
            my_size += 1 + 1;
        }
        if self.av1 != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.i444.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.h264 != false {
            os.write_bool(1, self.h264)?;
        }
        if self.h265 != false {
            os.write_bool(2, self.h265)?;
        }
        if self.vp8 != false {
            os.write_bool(3, self.vp8)?;
        }
        if self.av1 != false {
            os.write_bool(4, self.av1)?;
        }
        if let Some(v) = self.i444.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SupportedEncoding {
        SupportedEncoding::new()
    }

    fn clear(&mut self) {
        self.h264 = false;
        self.h265 = false;
        self.vp8 = false;
        self.av1 = false;
        self.i444.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SupportedEncoding {
        static instance: SupportedEncoding = SupportedEncoding {
            h264: false,
            h265: false,
            vp8: false,
            av1: false,
            i444: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SupportedEncoding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SupportedEncoding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SupportedEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedEncoding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PeerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeerInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.PeerInfo.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.hostname)
    pub hostname: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.platform)
    pub platform: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.displays)
    pub displays: ::std::vec::Vec<DisplayInfo>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.current_display)
    pub current_display: i32,
    // @@protoc_insertion_point(field:hbb.PeerInfo.sas_enabled)
    pub sas_enabled: bool,
    // @@protoc_insertion_point(field:hbb.PeerInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.features)
    pub features: ::protobuf::MessageField<Features>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.encoding)
    pub encoding: ::protobuf::MessageField<SupportedEncoding>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.resolutions)
    pub resolutions: ::protobuf::MessageField<SupportedResolutions>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.platform_additions)
    pub platform_additions: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.windows_sessions)
    pub windows_sessions: ::protobuf::MessageField<WindowsSessions>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PeerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerInfo {
    fn default() -> &'a PeerInfo {
        <PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PeerInfo {
    pub fn new() -> PeerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &PeerInfo| { &m.username },
            |m: &mut PeerInfo| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &PeerInfo| { &m.hostname },
            |m: &mut PeerInfo| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &PeerInfo| { &m.platform },
            |m: &mut PeerInfo| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "displays",
            |m: &PeerInfo| { &m.displays },
            |m: &mut PeerInfo| { &mut m.displays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_display",
            |m: &PeerInfo| { &m.current_display },
            |m: &mut PeerInfo| { &mut m.current_display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sas_enabled",
            |m: &PeerInfo| { &m.sas_enabled },
            |m: &mut PeerInfo| { &mut m.sas_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &PeerInfo| { &m.version },
            |m: &mut PeerInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Features>(
            "features",
            |m: &PeerInfo| { &m.features },
            |m: &mut PeerInfo| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SupportedEncoding>(
            "encoding",
            |m: &PeerInfo| { &m.encoding },
            |m: &mut PeerInfo| { &mut m.encoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SupportedResolutions>(
            "resolutions",
            |m: &PeerInfo| { &m.resolutions },
            |m: &mut PeerInfo| { &mut m.resolutions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform_additions",
            |m: &PeerInfo| { &m.platform_additions },
            |m: &mut PeerInfo| { &mut m.platform_additions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowsSessions>(
            "windows_sessions",
            |m: &PeerInfo| { &m.windows_sessions },
            |m: &mut PeerInfo| { &mut m.windows_sessions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerInfo>(
            "PeerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerInfo {
    const NAME: &'static str = "PeerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.hostname = is.read_string()?;
                },
                26 => {
                    self.platform = is.read_string()?;
                },
                34 => {
                    self.displays.push(is.read_message()?);
                },
                40 => {
                    self.current_display = is.read_int32()?;
                },
                48 => {
                    self.sas_enabled = is.read_bool()?;
                },
                58 => {
                    self.version = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.features)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encoding)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resolutions)?;
                },
                98 => {
                    self.platform_additions = is.read_string()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windows_sessions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hostname);
        }
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.platform);
        }
        for value in &self.displays {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.current_display != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.current_display);
        }
        if self.sas_enabled != false {
            my_size += 1 + 1;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version);
        }
        if let Some(v) = self.features.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.encoding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resolutions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.platform_additions.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.platform_additions);
        }
        if let Some(v) = self.windows_sessions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.hostname.is_empty() {
            os.write_string(2, &self.hostname)?;
        }
        if !self.platform.is_empty() {
            os.write_string(3, &self.platform)?;
        }
        for v in &self.displays {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.current_display != 0 {
            os.write_int32(5, self.current_display)?;
        }
        if self.sas_enabled != false {
            os.write_bool(6, self.sas_enabled)?;
        }
        if !self.version.is_empty() {
            os.write_string(7, &self.version)?;
        }
        if let Some(v) = self.features.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.encoding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.resolutions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if !self.platform_additions.is_empty() {
            os.write_string(12, &self.platform_additions)?;
        }
        if let Some(v) = self.windows_sessions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerInfo {
        PeerInfo::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.hostname.clear();
        self.platform.clear();
        self.displays.clear();
        self.current_display = 0;
        self.sas_enabled = false;
        self.version.clear();
        self.features.clear();
        self.encoding.clear();
        self.resolutions.clear();
        self.platform_additions.clear();
        self.windows_sessions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerInfo {
        static instance: PeerInfo = PeerInfo {
            username: ::std::string::String::new(),
            hostname: ::std::string::String::new(),
            platform: ::std::string::String::new(),
            displays: ::std::vec::Vec::new(),
            current_display: 0,
            sas_enabled: false,
            version: ::std::string::String::new(),
            features: ::protobuf::MessageField::none(),
            encoding: ::protobuf::MessageField::none(),
            resolutions: ::protobuf::MessageField::none(),
            platform_additions: ::std::string::String::new(),
            windows_sessions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.WindowsSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WindowsSession {
    // message fields
    // @@protoc_insertion_point(field:hbb.WindowsSession.sid)
    pub sid: u32,
    // @@protoc_insertion_point(field:hbb.WindowsSession.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.WindowsSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowsSession {
    fn default() -> &'a WindowsSession {
        <WindowsSession as ::protobuf::Message>::default_instance()
    }
}

impl WindowsSession {
    pub fn new() -> WindowsSession {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sid",
            |m: &WindowsSession| { &m.sid },
            |m: &mut WindowsSession| { &mut m.sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &WindowsSession| { &m.name },
            |m: &mut WindowsSession| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowsSession>(
            "WindowsSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowsSession {
    const NAME: &'static str = "WindowsSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sid = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sid != 0 {
            os.write_uint32(1, self.sid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowsSession {
        WindowsSession::new()
    }

    fn clear(&mut self) {
        self.sid = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowsSession {
        static instance: WindowsSession = WindowsSession {
            sid: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowsSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowsSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowsSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.LoginResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginResponse {
    // message oneof groups
    pub union: ::std::option::Option<login_response::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.LoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // string error = 1;

    pub fn error(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(login_response::Union::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(login_response::Union::Error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::Error(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .hbb.PeerInfo peer_info = 2;

    pub fn peer_info(&self) -> &PeerInfo {
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(ref v)) => v,
            _ => <PeerInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peer_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_peer_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_info(&mut self, v: PeerInfo) {
        self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peer_info(&mut self) -> &mut PeerInfo {
        if let ::std::option::Option::Some(login_response::Union::PeerInfo(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(PeerInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_info(&mut self) -> PeerInfo {
        if self.has_peer_info() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::PeerInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PeerInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "error",
            LoginResponse::has_error,
            LoginResponse::error,
            LoginResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeerInfo>(
            "peer_info",
            LoginResponse::has_peer_info,
            LoginResponse::peer_info,
            LoginResponse::mut_peer_info,
            LoginResponse::set_peer_info,
        ));
        oneofs.push(login_response::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginResponse>(
            "LoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginResponse {
    const NAME: &'static str = "LoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(login_response::Union::Error(is.read_string()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::Error(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &login_response::Union::PeerInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::Error(ref v) => {
                    os.write_string(1, v)?;
                },
                &login_response::Union::PeerInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: LoginResponse = LoginResponse {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginResponse`
pub mod login_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.LoginResponse.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.LoginResponse.error)
        Error(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.LoginResponse.peer_info)
        PeerInfo(super::PeerInfo),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.TouchScaleUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchScaleUpdate {
    // message fields
    // @@protoc_insertion_point(field:hbb.TouchScaleUpdate.scale)
    pub scale: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TouchScaleUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchScaleUpdate {
    fn default() -> &'a TouchScaleUpdate {
        <TouchScaleUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TouchScaleUpdate {
    pub fn new() -> TouchScaleUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale",
            |m: &TouchScaleUpdate| { &m.scale },
            |m: &mut TouchScaleUpdate| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchScaleUpdate>(
            "TouchScaleUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchScaleUpdate {
    const NAME: &'static str = "TouchScaleUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scale = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.scale != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.scale);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.scale != 0 {
            os.write_int32(1, self.scale)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchScaleUpdate {
        TouchScaleUpdate::new()
    }

    fn clear(&mut self) {
        self.scale = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchScaleUpdate {
        static instance: TouchScaleUpdate = TouchScaleUpdate {
            scale: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchScaleUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchScaleUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchScaleUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchScaleUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.TouchPanStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchPanStart {
    // message fields
    // @@protoc_insertion_point(field:hbb.TouchPanStart.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.TouchPanStart.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TouchPanStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchPanStart {
    fn default() -> &'a TouchPanStart {
        <TouchPanStart as ::protobuf::Message>::default_instance()
    }
}

impl TouchPanStart {
    pub fn new() -> TouchPanStart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &TouchPanStart| { &m.x },
            |m: &mut TouchPanStart| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &TouchPanStart| { &m.y },
            |m: &mut TouchPanStart| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchPanStart>(
            "TouchPanStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchPanStart {
    const NAME: &'static str = "TouchPanStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_int32()?;
                },
                16 => {
                    self.y = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchPanStart {
        TouchPanStart::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchPanStart {
        static instance: TouchPanStart = TouchPanStart {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchPanStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchPanStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchPanStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchPanStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.TouchPanUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchPanUpdate {
    // message fields
    // @@protoc_insertion_point(field:hbb.TouchPanUpdate.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.TouchPanUpdate.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TouchPanUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchPanUpdate {
    fn default() -> &'a TouchPanUpdate {
        <TouchPanUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TouchPanUpdate {
    pub fn new() -> TouchPanUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &TouchPanUpdate| { &m.x },
            |m: &mut TouchPanUpdate| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &TouchPanUpdate| { &m.y },
            |m: &mut TouchPanUpdate| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchPanUpdate>(
            "TouchPanUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchPanUpdate {
    const NAME: &'static str = "TouchPanUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_int32()?;
                },
                16 => {
                    self.y = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchPanUpdate {
        TouchPanUpdate::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchPanUpdate {
        static instance: TouchPanUpdate = TouchPanUpdate {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchPanUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchPanUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchPanUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchPanUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.TouchPanEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchPanEnd {
    // message fields
    // @@protoc_insertion_point(field:hbb.TouchPanEnd.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.TouchPanEnd.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TouchPanEnd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchPanEnd {
    fn default() -> &'a TouchPanEnd {
        <TouchPanEnd as ::protobuf::Message>::default_instance()
    }
}

impl TouchPanEnd {
    pub fn new() -> TouchPanEnd {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &TouchPanEnd| { &m.x },
            |m: &mut TouchPanEnd| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &TouchPanEnd| { &m.y },
            |m: &mut TouchPanEnd| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchPanEnd>(
            "TouchPanEnd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchPanEnd {
    const NAME: &'static str = "TouchPanEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_int32()?;
                },
                16 => {
                    self.y = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchPanEnd {
        TouchPanEnd::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchPanEnd {
        static instance: TouchPanEnd = TouchPanEnd {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchPanEnd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchPanEnd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchPanEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchPanEnd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.TouchEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchEvent {
    // message oneof groups
    pub union: ::std::option::Option<touch_event::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TouchEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchEvent {
    fn default() -> &'a TouchEvent {
        <TouchEvent as ::protobuf::Message>::default_instance()
    }
}

impl TouchEvent {
    pub fn new() -> TouchEvent {
        ::std::default::Default::default()
    }

    // .hbb.TouchScaleUpdate scale_update = 1;

    pub fn scale_update(&self) -> &TouchScaleUpdate {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::ScaleUpdate(ref v)) => v,
            _ => <TouchScaleUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_scale_update(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_scale_update(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::ScaleUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scale_update(&mut self, v: TouchScaleUpdate) {
        self.union = ::std::option::Option::Some(touch_event::Union::ScaleUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scale_update(&mut self) -> &mut TouchScaleUpdate {
        if let ::std::option::Option::Some(touch_event::Union::ScaleUpdate(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(touch_event::Union::ScaleUpdate(TouchScaleUpdate::new()));
        }
        match self.union {
            ::std::option::Option::Some(touch_event::Union::ScaleUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scale_update(&mut self) -> TouchScaleUpdate {
        if self.has_scale_update() {
            match self.union.take() {
                ::std::option::Option::Some(touch_event::Union::ScaleUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            TouchScaleUpdate::new()
        }
    }

    // .hbb.TouchPanStart pan_start = 2;

    pub fn pan_start(&self) -> &TouchPanStart {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanStart(ref v)) => v,
            _ => <TouchPanStart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pan_start(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_pan_start(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanStart(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pan_start(&mut self, v: TouchPanStart) {
        self.union = ::std::option::Option::Some(touch_event::Union::PanStart(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pan_start(&mut self) -> &mut TouchPanStart {
        if let ::std::option::Option::Some(touch_event::Union::PanStart(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(touch_event::Union::PanStart(TouchPanStart::new()));
        }
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanStart(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pan_start(&mut self) -> TouchPanStart {
        if self.has_pan_start() {
            match self.union.take() {
                ::std::option::Option::Some(touch_event::Union::PanStart(v)) => v,
                _ => panic!(),
            }
        } else {
            TouchPanStart::new()
        }
    }

    // .hbb.TouchPanUpdate pan_update = 3;

    pub fn pan_update(&self) -> &TouchPanUpdate {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanUpdate(ref v)) => v,
            _ => <TouchPanUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pan_update(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_pan_update(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pan_update(&mut self, v: TouchPanUpdate) {
        self.union = ::std::option::Option::Some(touch_event::Union::PanUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pan_update(&mut self) -> &mut TouchPanUpdate {
        if let ::std::option::Option::Some(touch_event::Union::PanUpdate(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(touch_event::Union::PanUpdate(TouchPanUpdate::new()));
        }
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pan_update(&mut self) -> TouchPanUpdate {
        if self.has_pan_update() {
            match self.union.take() {
                ::std::option::Option::Some(touch_event::Union::PanUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            TouchPanUpdate::new()
        }
    }

    // .hbb.TouchPanEnd pan_end = 4;

    pub fn pan_end(&self) -> &TouchPanEnd {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanEnd(ref v)) => v,
            _ => <TouchPanEnd as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pan_end(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_pan_end(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanEnd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pan_end(&mut self, v: TouchPanEnd) {
        self.union = ::std::option::Option::Some(touch_event::Union::PanEnd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pan_end(&mut self) -> &mut TouchPanEnd {
        if let ::std::option::Option::Some(touch_event::Union::PanEnd(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(touch_event::Union::PanEnd(TouchPanEnd::new()));
        }
        match self.union {
            ::std::option::Option::Some(touch_event::Union::PanEnd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pan_end(&mut self) -> TouchPanEnd {
        if self.has_pan_end() {
            match self.union.take() {
                ::std::option::Option::Some(touch_event::Union::PanEnd(v)) => v,
                _ => panic!(),
            }
        } else {
            TouchPanEnd::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TouchScaleUpdate>(
            "scale_update",
            TouchEvent::has_scale_update,
            TouchEvent::scale_update,
            TouchEvent::mut_scale_update,
            TouchEvent::set_scale_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TouchPanStart>(
            "pan_start",
            TouchEvent::has_pan_start,
            TouchEvent::pan_start,
            TouchEvent::mut_pan_start,
            TouchEvent::set_pan_start,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TouchPanUpdate>(
            "pan_update",
            TouchEvent::has_pan_update,
            TouchEvent::pan_update,
            TouchEvent::mut_pan_update,
            TouchEvent::set_pan_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TouchPanEnd>(
            "pan_end",
            TouchEvent::has_pan_end,
            TouchEvent::pan_end,
            TouchEvent::mut_pan_end,
            TouchEvent::set_pan_end,
        ));
        oneofs.push(touch_event::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchEvent>(
            "TouchEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchEvent {
    const NAME: &'static str = "TouchEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(touch_event::Union::ScaleUpdate(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(touch_event::Union::PanStart(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(touch_event::Union::PanUpdate(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(touch_event::Union::PanEnd(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &touch_event::Union::ScaleUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &touch_event::Union::PanStart(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &touch_event::Union::PanUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &touch_event::Union::PanEnd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &touch_event::Union::ScaleUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &touch_event::Union::PanStart(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &touch_event::Union::PanUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &touch_event::Union::PanEnd(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchEvent {
        TouchEvent::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchEvent {
        static instance: TouchEvent = TouchEvent {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TouchEvent`
pub mod touch_event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.TouchEvent.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.TouchEvent.scale_update)
        ScaleUpdate(super::TouchScaleUpdate),
        // @@protoc_insertion_point(oneof_field:hbb.TouchEvent.pan_start)
        PanStart(super::TouchPanStart),
        // @@protoc_insertion_point(oneof_field:hbb.TouchEvent.pan_update)
        PanUpdate(super::TouchPanUpdate),
        // @@protoc_insertion_point(oneof_field:hbb.TouchEvent.pan_end)
        PanEnd(super::TouchPanEnd),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TouchEvent as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.PointerDeviceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PointerDeviceEvent {
    // message fields
    // @@protoc_insertion_point(field:hbb.PointerDeviceEvent.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ControlKey>>,
    // message oneof groups
    pub union: ::std::option::Option<pointer_device_event::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PointerDeviceEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PointerDeviceEvent {
    fn default() -> &'a PointerDeviceEvent {
        <PointerDeviceEvent as ::protobuf::Message>::default_instance()
    }
}

impl PointerDeviceEvent {
    pub fn new() -> PointerDeviceEvent {
        ::std::default::Default::default()
    }

    // .hbb.TouchEvent touch_event = 1;

    pub fn touch_event(&self) -> &TouchEvent {
        match self.union {
            ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(ref v)) => v,
            _ => <TouchEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_touch_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_touch_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_touch_event(&mut self, v: TouchEvent) {
        self.union = ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_touch_event(&mut self) -> &mut TouchEvent {
        if let ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(TouchEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_touch_event(&mut self) -> TouchEvent {
        if self.has_touch_event() {
            match self.union.take() {
                ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            TouchEvent::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TouchEvent>(
            "touch_event",
            PointerDeviceEvent::has_touch_event,
            PointerDeviceEvent::touch_event,
            PointerDeviceEvent::mut_touch_event,
            PointerDeviceEvent::set_touch_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &PointerDeviceEvent| { &m.modifiers },
            |m: &mut PointerDeviceEvent| { &mut m.modifiers },
        ));
        oneofs.push(pointer_device_event::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PointerDeviceEvent>(
            "PointerDeviceEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PointerDeviceEvent {
    const NAME: &'static str = "PointerDeviceEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(pointer_device_event::Union::TouchEvent(is.read_message()?));
                },
                16 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(2, &self.modifiers);
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &pointer_device_event::Union::TouchEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_enum_or_unknown(2, &self.modifiers)?;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &pointer_device_event::Union::TouchEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PointerDeviceEvent {
        PointerDeviceEvent::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PointerDeviceEvent {
        static instance: PointerDeviceEvent = PointerDeviceEvent {
            modifiers: ::std::vec::Vec::new(),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PointerDeviceEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PointerDeviceEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PointerDeviceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PointerDeviceEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PointerDeviceEvent`
pub mod pointer_device_event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.PointerDeviceEvent.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.PointerDeviceEvent.touch_event)
        TouchEvent(super::TouchEvent),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PointerDeviceEvent as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.MouseEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MouseEvent {
    // message fields
    // @@protoc_insertion_point(field:hbb.MouseEvent.mask)
    pub mask: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ControlKey>>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.MouseEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MouseEvent {
    fn default() -> &'a MouseEvent {
        <MouseEvent as ::protobuf::Message>::default_instance()
    }
}

impl MouseEvent {
    pub fn new() -> MouseEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mask",
            |m: &MouseEvent| { &m.mask },
            |m: &mut MouseEvent| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &MouseEvent| { &m.x },
            |m: &mut MouseEvent| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &MouseEvent| { &m.y },
            |m: &mut MouseEvent| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &MouseEvent| { &m.modifiers },
            |m: &mut MouseEvent| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MouseEvent>(
            "MouseEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MouseEvent {
    const NAME: &'static str = "MouseEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mask = is.read_int32()?;
                },
                16 => {
                    self.x = is.read_sint32()?;
                },
                24 => {
                    self.y = is.read_sint32()?;
                },
                32 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mask != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.mask);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.y);
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.modifiers);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mask != 0 {
            os.write_int32(1, self.mask)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        os.write_repeated_packed_enum_or_unknown(4, &self.modifiers)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MouseEvent {
        MouseEvent::new()
    }

    fn clear(&mut self) {
        self.mask = 0;
        self.x = 0;
        self.y = 0;
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MouseEvent {
        static instance: MouseEvent = MouseEvent {
            mask: 0,
            x: 0,
            y: 0,
            modifiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MouseEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MouseEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MouseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MouseEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.KeyEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyEvent {
    // message fields
    // @@protoc_insertion_point(field:hbb.KeyEvent.down)
    pub down: bool,
    // @@protoc_insertion_point(field:hbb.KeyEvent.press)
    pub press: bool,
    // @@protoc_insertion_point(field:hbb.KeyEvent.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ControlKey>>,
    // @@protoc_insertion_point(field:hbb.KeyEvent.mode)
    pub mode: ::protobuf::EnumOrUnknown<KeyboardMode>,
    // message oneof groups
    pub union: ::std::option::Option<key_event::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.KeyEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyEvent {
    fn default() -> &'a KeyEvent {
        <KeyEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyEvent {
    pub fn new() -> KeyEvent {
        ::std::default::Default::default()
    }

    // .hbb.ControlKey control_key = 3;

    pub fn control_key(&self) -> ControlKey {
        match self.union {
            ::std::option::Option::Some(key_event::Union::ControlKey(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => ControlKey::Unknown,
        }
    }

    pub fn clear_control_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_control_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::ControlKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_key(&mut self, v: ControlKey) {
        self.union = ::std::option::Option::Some(key_event::Union::ControlKey(::protobuf::EnumOrUnknown::new(v)))
    }

    // uint32 chr = 4;

    pub fn chr(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Chr(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_chr(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chr(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Chr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chr(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::Chr(v))
    }

    // uint32 unicode = 5;

    pub fn unicode(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Unicode(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_unicode(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_unicode(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Unicode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unicode(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::Unicode(v))
    }

    // string seq = 6;

    pub fn seq(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_seq(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(key_event::Union::Seq(v))
    }

    // Mutable pointer to the field.
    pub fn mut_seq(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(key_event::Union::Seq(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(key_event::Union::Seq(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_seq(&mut self) -> ::std::string::String {
        if self.has_seq() {
            match self.union.take() {
                ::std::option::Option::Some(key_event::Union::Seq(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 win2win_hotkey = 7;

    pub fn win2win_hotkey(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Win2winHotkey(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_win2win_hotkey(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_win2win_hotkey(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Win2winHotkey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_win2win_hotkey(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::Win2winHotkey(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "down",
            |m: &KeyEvent| { &m.down },
            |m: &mut KeyEvent| { &mut m.down },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "press",
            |m: &KeyEvent| { &m.press },
            |m: &mut KeyEvent| { &mut m.press },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "control_key",
            |message: &KeyEvent| match &message.union {
                ::std::option::Option::Some(key_event::Union::ControlKey(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut KeyEvent, e: ::protobuf::EnumOrUnknown<ControlKey>| {
                message.union = ::std::option::Option::Some(key_event::Union::ControlKey(e));
            },
            ControlKey::Unknown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "chr",
            KeyEvent::has_chr,
            KeyEvent::chr,
            KeyEvent::set_chr,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "unicode",
            KeyEvent::has_unicode,
            KeyEvent::unicode,
            KeyEvent::set_unicode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "seq",
            KeyEvent::has_seq,
            KeyEvent::seq,
            KeyEvent::set_seq,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "win2win_hotkey",
            KeyEvent::has_win2win_hotkey,
            KeyEvent::win2win_hotkey,
            KeyEvent::set_win2win_hotkey,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &KeyEvent| { &m.modifiers },
            |m: &mut KeyEvent| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &KeyEvent| { &m.mode },
            |m: &mut KeyEvent| { &mut m.mode },
        ));
        oneofs.push(key_event::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyEvent>(
            "KeyEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyEvent {
    const NAME: &'static str = "KeyEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.down = is.read_bool()?;
                },
                16 => {
                    self.press = is.read_bool()?;
                },
                24 => {
                    self.union = ::std::option::Option::Some(key_event::Union::ControlKey(is.read_enum_or_unknown()?));
                },
                32 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Chr(is.read_uint32()?));
                },
                40 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Unicode(is.read_uint32()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Seq(is.read_string()?));
                },
                56 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Win2winHotkey(is.read_uint32()?));
                },
                64 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                66 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                72 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.down != false {
            my_size += 1 + 1;
        }
        if self.press != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(8, &self.modifiers);
        if self.mode != ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy) {
            my_size += ::protobuf::rt::int32_size(9, self.mode.value());
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::ControlKey(v) => {
                    my_size += ::protobuf::rt::int32_size(3, v.value());
                },
                &key_event::Union::Chr(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
                &key_event::Union::Unicode(v) => {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                },
                &key_event::Union::Seq(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
                &key_event::Union::Win2winHotkey(v) => {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.down != false {
            os.write_bool(1, self.down)?;
        }
        if self.press != false {
            os.write_bool(2, self.press)?;
        }
        os.write_repeated_packed_enum_or_unknown(8, &self.modifiers)?;
        if self.mode != ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::ControlKey(v) => {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &key_event::Union::Chr(v) => {
                    os.write_uint32(4, v)?;
                },
                &key_event::Union::Unicode(v) => {
                    os.write_uint32(5, v)?;
                },
                &key_event::Union::Seq(ref v) => {
                    os.write_string(6, v)?;
                },
                &key_event::Union::Win2winHotkey(v) => {
                    os.write_uint32(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyEvent {
        KeyEvent::new()
    }

    fn clear(&mut self) {
        self.down = false;
        self.press = false;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.modifiers.clear();
        self.mode = ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyEvent {
        static instance: KeyEvent = KeyEvent {
            down: false,
            press: false,
            modifiers: ::std::vec::Vec::new(),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KeyEvent`
pub mod key_event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.KeyEvent.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.control_key)
        ControlKey(::protobuf::EnumOrUnknown<super::ControlKey>),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.chr)
        Chr(u32),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.unicode)
        Unicode(u32),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.seq)
        Seq(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.win2win_hotkey)
        Win2winHotkey(u32),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::KeyEvent as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.CursorData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CursorData {
    // message fields
    // @@protoc_insertion_point(field:hbb.CursorData.id)
    pub id: u64,
    // @@protoc_insertion_point(field:hbb.CursorData.hotx)
    pub hotx: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.hoty)
    pub hoty: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.colors)
    pub colors: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CursorData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CursorData {
    fn default() -> &'a CursorData {
        <CursorData as ::protobuf::Message>::default_instance()
    }
}

impl CursorData {
    pub fn new() -> CursorData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CursorData| { &m.id },
            |m: &mut CursorData| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hotx",
            |m: &CursorData| { &m.hotx },
            |m: &mut CursorData| { &mut m.hotx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hoty",
            |m: &CursorData| { &m.hoty },
            |m: &mut CursorData| { &mut m.hoty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &CursorData| { &m.width },
            |m: &mut CursorData| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &CursorData| { &m.height },
            |m: &mut CursorData| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "colors",
            |m: &CursorData| { &m.colors },
            |m: &mut CursorData| { &mut m.colors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorData>(
            "CursorData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CursorData {
    const NAME: &'static str = "CursorData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                16 => {
                    self.hotx = is.read_sint32()?;
                },
                24 => {
                    self.hoty = is.read_sint32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.height = is.read_int32()?;
                },
                50 => {
                    self.colors = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.hotx != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.hotx);
        }
        if self.hoty != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.hoty);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.height);
        }
        if !self.colors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.colors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.hotx != 0 {
            os.write_sint32(2, self.hotx)?;
        }
        if self.hoty != 0 {
            os.write_sint32(3, self.hoty)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        if !self.colors.is_empty() {
            os.write_bytes(6, &self.colors)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CursorData {
        CursorData::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.hotx = 0;
        self.hoty = 0;
        self.width = 0;
        self.height = 0;
        self.colors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CursorData {
        static instance: CursorData = CursorData {
            id: 0,
            hotx: 0,
            hoty: 0,
            width: 0,
            height: 0,
            colors: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CursorData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CursorData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CursorData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CursorPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CursorPosition {
    // message fields
    // @@protoc_insertion_point(field:hbb.CursorPosition.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.CursorPosition.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CursorPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CursorPosition {
    fn default() -> &'a CursorPosition {
        <CursorPosition as ::protobuf::Message>::default_instance()
    }
}

impl CursorPosition {
    pub fn new() -> CursorPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &CursorPosition| { &m.x },
            |m: &mut CursorPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &CursorPosition| { &m.y },
            |m: &mut CursorPosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorPosition>(
            "CursorPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CursorPosition {
    const NAME: &'static str = "CursorPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_sint32()?;
                },
                16 => {
                    self.y = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CursorPosition {
        CursorPosition::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CursorPosition {
        static instance: CursorPosition = CursorPosition {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CursorPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CursorPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CursorPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Hash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Hash {
    // message fields
    // @@protoc_insertion_point(field:hbb.Hash.salt)
    pub salt: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.Hash.challenge)
    pub challenge: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Hash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "salt",
            |m: &Hash| { &m.salt },
            |m: &mut Hash| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "challenge",
            |m: &Hash| { &m.challenge },
            |m: &mut Hash| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hash>(
            "Hash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hash {
    const NAME: &'static str = "Hash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = is.read_string()?;
                },
                18 => {
                    self.challenge = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.salt);
        }
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.challenge);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.salt.is_empty() {
            os.write_string(1, &self.salt)?;
        }
        if !self.challenge.is_empty() {
            os.write_string(2, &self.challenge)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn clear(&mut self) {
        self.salt.clear();
        self.challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hash {
        static instance: Hash = Hash {
            salt: ::std::string::String::new(),
            challenge: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Clipboard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Clipboard {
    // message fields
    // @@protoc_insertion_point(field:hbb.Clipboard.compress)
    pub compress: bool,
    // @@protoc_insertion_point(field:hbb.Clipboard.content)
    pub content: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.Clipboard.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.Clipboard.height)
    pub height: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Clipboard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Clipboard {
    fn default() -> &'a Clipboard {
        <Clipboard as ::protobuf::Message>::default_instance()
    }
}

impl Clipboard {
    pub fn new() -> Clipboard {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &Clipboard| { &m.compress },
            |m: &mut Clipboard| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Clipboard| { &m.content },
            |m: &mut Clipboard| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &Clipboard| { &m.width },
            |m: &mut Clipboard| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Clipboard| { &m.height },
            |m: &mut Clipboard| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Clipboard>(
            "Clipboard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Clipboard {
    const NAME: &'static str = "Clipboard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                18 => {
                    self.content = is.read_tokio_bytes()?;
                },
                24 => {
                    self.width = is.read_int32()?;
                },
                32 => {
                    self.height = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Clipboard {
        Clipboard::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.content.clear();
        self.width = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Clipboard {
        static instance: Clipboard = Clipboard {
            compress: false,
            content: ::bytes::Bytes::new(),
            width: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Clipboard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Clipboard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Clipboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Clipboard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileEntry {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileEntry.entry_type)
    pub entry_type: ::protobuf::EnumOrUnknown<FileType>,
    // @@protoc_insertion_point(field:hbb.FileEntry.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileEntry.is_hidden)
    pub is_hidden: bool,
    // @@protoc_insertion_point(field:hbb.FileEntry.size)
    pub size: u64,
    // @@protoc_insertion_point(field:hbb.FileEntry.modified_time)
    pub modified_time: u64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileEntry {
    fn default() -> &'a FileEntry {
        <FileEntry as ::protobuf::Message>::default_instance()
    }
}

impl FileEntry {
    pub fn new() -> FileEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entry_type",
            |m: &FileEntry| { &m.entry_type },
            |m: &mut FileEntry| { &mut m.entry_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FileEntry| { &m.name },
            |m: &mut FileEntry| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_hidden",
            |m: &FileEntry| { &m.is_hidden },
            |m: &mut FileEntry| { &mut m.is_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &FileEntry| { &m.size },
            |m: &mut FileEntry| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modified_time",
            |m: &FileEntry| { &m.modified_time },
            |m: &mut FileEntry| { &mut m.modified_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileEntry>(
            "FileEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileEntry {
    const NAME: &'static str = "FileEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entry_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.is_hidden = is.read_bool()?;
                },
                32 => {
                    self.size = is.read_uint64()?;
                },
                40 => {
                    self.modified_time = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.entry_type != ::protobuf::EnumOrUnknown::new(FileType::Dir) {
            my_size += ::protobuf::rt::int32_size(1, self.entry_type.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.is_hidden != false {
            my_size += 1 + 1;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.size);
        }
        if self.modified_time != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.modified_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.entry_type != ::protobuf::EnumOrUnknown::new(FileType::Dir) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.entry_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.is_hidden != false {
            os.write_bool(3, self.is_hidden)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if self.modified_time != 0 {
            os.write_uint64(5, self.modified_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileEntry {
        FileEntry::new()
    }

    fn clear(&mut self) {
        self.entry_type = ::protobuf::EnumOrUnknown::new(FileType::Dir);
        self.name.clear();
        self.is_hidden = false;
        self.size = 0;
        self.modified_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileEntry {
        static instance: FileEntry = FileEntry {
            entry_type: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            is_hidden: false,
            size: 0,
            modified_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileDirectory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDirectory {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileDirectory.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileDirectory.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileDirectory.entries)
    pub entries: ::std::vec::Vec<FileEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileDirectory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDirectory {
    fn default() -> &'a FileDirectory {
        <FileDirectory as ::protobuf::Message>::default_instance()
    }
}

impl FileDirectory {
    pub fn new() -> FileDirectory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirectory| { &m.id },
            |m: &mut FileDirectory| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirectory| { &m.path },
            |m: &mut FileDirectory| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &FileDirectory| { &m.entries },
            |m: &mut FileDirectory| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirectory>(
            "FileDirectory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDirectory {
    const NAME: &'static str = "FileDirectory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDirectory {
        FileDirectory::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDirectory {
        static instance: FileDirectory = FileDirectory {
            id: 0,
            path: ::std::string::String::new(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDirectory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDirectory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirectory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.ReadDir)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReadDir {
    // message fields
    // @@protoc_insertion_point(field:hbb.ReadDir.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ReadDir.include_hidden)
    pub include_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ReadDir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadDir {
    fn default() -> &'a ReadDir {
        <ReadDir as ::protobuf::Message>::default_instance()
    }
}

impl ReadDir {
    pub fn new() -> ReadDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadDir| { &m.path },
            |m: &mut ReadDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadDir| { &m.include_hidden },
            |m: &mut ReadDir| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadDir>(
            "ReadDir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadDir {
    const NAME: &'static str = "ReadDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                16 => {
                    self.include_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(2, self.include_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadDir {
        ReadDir::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.include_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadDir {
        static instance: ReadDir = ReadDir {
            path: ::std::string::String::new(),
            include_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadDir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadDir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadDir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.ReadAllFiles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReadAllFiles {
    // message fields
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.include_hidden)
    pub include_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ReadAllFiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadAllFiles {
    fn default() -> &'a ReadAllFiles {
        <ReadAllFiles as ::protobuf::Message>::default_instance()
    }
}

impl ReadAllFiles {
    pub fn new() -> ReadAllFiles {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ReadAllFiles| { &m.id },
            |m: &mut ReadAllFiles| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadAllFiles| { &m.path },
            |m: &mut ReadAllFiles| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadAllFiles| { &m.include_hidden },
            |m: &mut ReadAllFiles| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadAllFiles>(
            "ReadAllFiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadAllFiles {
    const NAME: &'static str = "ReadAllFiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.include_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadAllFiles {
        ReadAllFiles::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadAllFiles {
        static instance: ReadAllFiles = ReadAllFiles {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadAllFiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadAllFiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadAllFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllFiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileAction {
    // message oneof groups
    pub union: ::std::option::Option<file_action::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileAction {
    fn default() -> &'a FileAction {
        <FileAction as ::protobuf::Message>::default_instance()
    }
}

impl FileAction {
    pub fn new() -> FileAction {
        ::std::default::Default::default()
    }

    // .hbb.ReadDir read_dir = 1;

    pub fn read_dir(&self) -> &ReadDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(ref v)) => v,
            _ => <ReadDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_read_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_dir(&mut self, v: ReadDir) {
        self.union = ::std::option::Option::Some(file_action::Union::ReadDir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_dir(&mut self) -> &mut ReadDir {
        if let ::std::option::Option::Some(file_action::Union::ReadDir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::ReadDir(ReadDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_dir(&mut self) -> ReadDir {
        if self.has_read_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::ReadDir(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadDir::new()
        }
    }

    // .hbb.FileTransferSendRequest send = 2;

    pub fn send(&self) -> &FileTransferSendRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(ref v)) => v,
            _ => <FileTransferSendRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_send(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: FileTransferSendRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::Send(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send(&mut self) -> &mut FileTransferSendRequest {
        if let ::std::option::Option::Some(file_action::Union::Send(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Send(FileTransferSendRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send(&mut self) -> FileTransferSendRequest {
        if self.has_send() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Send(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferSendRequest::new()
        }
    }

    // .hbb.FileTransferReceiveRequest receive = 3;

    pub fn receive(&self) -> &FileTransferReceiveRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(ref v)) => v,
            _ => <FileTransferReceiveRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_receive(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_receive(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: FileTransferReceiveRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::Receive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_receive(&mut self) -> &mut FileTransferReceiveRequest {
        if let ::std::option::Option::Some(file_action::Union::Receive(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Receive(FileTransferReceiveRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_receive(&mut self) -> FileTransferReceiveRequest {
        if self.has_receive() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Receive(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferReceiveRequest::new()
        }
    }

    // .hbb.FileDirCreate create = 4;

    pub fn create(&self) -> &FileDirCreate {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(ref v)) => v,
            _ => <FileDirCreate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: FileDirCreate) {
        self.union = ::std::option::Option::Some(file_action::Union::Create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut FileDirCreate {
        if let ::std::option::Option::Some(file_action::Union::Create(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Create(FileDirCreate::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> FileDirCreate {
        if self.has_create() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Create(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirCreate::new()
        }
    }

    // .hbb.FileRemoveDir remove_dir = 5;

    pub fn remove_dir(&self) -> &FileRemoveDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(ref v)) => v,
            _ => <FileRemoveDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_dir(&mut self, v: FileRemoveDir) {
        self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_dir(&mut self) -> &mut FileRemoveDir {
        if let ::std::option::Option::Some(file_action::Union::RemoveDir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(FileRemoveDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_dir(&mut self) -> FileRemoveDir {
        if self.has_remove_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::RemoveDir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveDir::new()
        }
    }

    // .hbb.FileRemoveFile remove_file = 6;

    pub fn remove_file(&self) -> &FileRemoveFile {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(ref v)) => v,
            _ => <FileRemoveFile as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_file(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_file(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_file(&mut self, v: FileRemoveFile) {
        self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_file(&mut self) -> &mut FileRemoveFile {
        if let ::std::option::Option::Some(file_action::Union::RemoveFile(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(FileRemoveFile::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_file(&mut self) -> FileRemoveFile {
        if self.has_remove_file() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::RemoveFile(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveFile::new()
        }
    }

    // .hbb.ReadAllFiles all_files = 7;

    pub fn all_files(&self) -> &ReadAllFiles {
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(ref v)) => v,
            _ => <ReadAllFiles as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_all_files(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_all_files(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_all_files(&mut self, v: ReadAllFiles) {
        self.union = ::std::option::Option::Some(file_action::Union::AllFiles(v))
    }

    // Mutable pointer to the field.
    pub fn mut_all_files(&mut self) -> &mut ReadAllFiles {
        if let ::std::option::Option::Some(file_action::Union::AllFiles(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::AllFiles(ReadAllFiles::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_all_files(&mut self) -> ReadAllFiles {
        if self.has_all_files() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::AllFiles(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadAllFiles::new()
        }
    }

    // .hbb.FileTransferCancel cancel = 8;

    pub fn cancel(&self) -> &FileTransferCancel {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(ref v)) => v,
            _ => <FileTransferCancel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cancel(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cancel(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancel(&mut self, v: FileTransferCancel) {
        self.union = ::std::option::Option::Some(file_action::Union::Cancel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancel(&mut self) -> &mut FileTransferCancel {
        if let ::std::option::Option::Some(file_action::Union::Cancel(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Cancel(FileTransferCancel::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancel(&mut self) -> FileTransferCancel {
        if self.has_cancel() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Cancel(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferCancel::new()
        }
    }

    // .hbb.FileTransferSendConfirmRequest send_confirm = 9;

    pub fn send_confirm(&self) -> &FileTransferSendConfirmRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(ref v)) => v,
            _ => <FileTransferSendConfirmRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_confirm(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_send_confirm(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_confirm(&mut self, v: FileTransferSendConfirmRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_confirm(&mut self) -> &mut FileTransferSendConfirmRequest {
        if let ::std::option::Option::Some(file_action::Union::SendConfirm(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(FileTransferSendConfirmRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_confirm(&mut self) -> FileTransferSendConfirmRequest {
        if self.has_send_confirm() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::SendConfirm(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferSendConfirmRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadDir>(
            "read_dir",
            FileAction::has_read_dir,
            FileAction::read_dir,
            FileAction::mut_read_dir,
            FileAction::set_read_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferSendRequest>(
            "send",
            FileAction::has_send,
            FileAction::send,
            FileAction::mut_send,
            FileAction::set_send,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferReceiveRequest>(
            "receive",
            FileAction::has_receive,
            FileAction::receive,
            FileAction::mut_receive,
            FileAction::set_receive,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirCreate>(
            "create",
            FileAction::has_create,
            FileAction::create,
            FileAction::mut_create,
            FileAction::set_create,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveDir>(
            "remove_dir",
            FileAction::has_remove_dir,
            FileAction::remove_dir,
            FileAction::mut_remove_dir,
            FileAction::set_remove_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveFile>(
            "remove_file",
            FileAction::has_remove_file,
            FileAction::remove_file,
            FileAction::mut_remove_file,
            FileAction::set_remove_file,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadAllFiles>(
            "all_files",
            FileAction::has_all_files,
            FileAction::all_files,
            FileAction::mut_all_files,
            FileAction::set_all_files,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferCancel>(
            "cancel",
            FileAction::has_cancel,
            FileAction::cancel,
            FileAction::mut_cancel,
            FileAction::set_cancel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferSendConfirmRequest>(
            "send_confirm",
            FileAction::has_send_confirm,
            FileAction::send_confirm,
            FileAction::mut_send_confirm,
            FileAction::set_send_confirm,
        ));
        oneofs.push(file_action::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileAction>(
            "FileAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileAction {
    const NAME: &'static str = "FileAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(file_action::Union::ReadDir(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Send(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Receive(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Create(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(file_action::Union::AllFiles(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Cancel(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::ReadDir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Send(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Receive(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::RemoveDir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::RemoveFile(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::AllFiles(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Cancel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::SendConfirm(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::ReadDir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_action::Union::Send(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_action::Union::Receive(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_action::Union::Create(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &file_action::Union::RemoveDir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &file_action::Union::RemoveFile(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &file_action::Union::AllFiles(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &file_action::Union::Cancel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &file_action::Union::SendConfirm(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileAction {
        FileAction::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileAction {
        static instance: FileAction = FileAction {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileAction`
pub mod file_action {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileAction.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.read_dir)
        ReadDir(super::ReadDir),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.send)
        Send(super::FileTransferSendRequest),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.receive)
        Receive(super::FileTransferReceiveRequest),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.create)
        Create(super::FileDirCreate),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.remove_dir)
        RemoveDir(super::FileRemoveDir),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.remove_file)
        RemoveFile(super::FileRemoveFile),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.all_files)
        AllFiles(super::ReadAllFiles),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.cancel)
        Cancel(super::FileTransferCancel),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.send_confirm)
        SendConfirm(super::FileTransferSendConfirmRequest),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileAction as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.FileTransferCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferCancel {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferCancel.id)
    pub id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferCancel {
    fn default() -> &'a FileTransferCancel {
        <FileTransferCancel as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferCancel {
    pub fn new() -> FileTransferCancel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferCancel| { &m.id },
            |m: &mut FileTransferCancel| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferCancel>(
            "FileTransferCancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferCancel {
    const NAME: &'static str = "FileTransferCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferCancel {
        FileTransferCancel::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferCancel {
        static instance: FileTransferCancel = FileTransferCancel {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferCancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferCancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileResponse {
    // message oneof groups
    pub union: ::std::option::Option<file_response::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileResponse {
    fn default() -> &'a FileResponse {
        <FileResponse as ::protobuf::Message>::default_instance()
    }
}

impl FileResponse {
    pub fn new() -> FileResponse {
        ::std::default::Default::default()
    }

    // .hbb.FileDirectory dir = 1;

    pub fn dir(&self) -> &FileDirectory {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(ref v)) => v,
            _ => <FileDirectory as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: FileDirectory) {
        self.union = ::std::option::Option::Some(file_response::Union::Dir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dir(&mut self) -> &mut FileDirectory {
        if let ::std::option::Option::Some(file_response::Union::Dir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Dir(FileDirectory::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dir(&mut self) -> FileDirectory {
        if self.has_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Dir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirectory::new()
        }
    }

    // .hbb.FileTransferBlock block = 2;

    pub fn block(&self) -> &FileTransferBlock {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(ref v)) => v,
            _ => <FileTransferBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: FileTransferBlock) {
        self.union = ::std::option::Option::Some(file_response::Union::Block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut FileTransferBlock {
        if let ::std::option::Option::Some(file_response::Union::Block(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Block(FileTransferBlock::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> FileTransferBlock {
        if self.has_block() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Block(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferBlock::new()
        }
    }

    // .hbb.FileTransferError error = 3;

    pub fn error(&self) -> &FileTransferError {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(ref v)) => v,
            _ => <FileTransferError as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: FileTransferError) {
        self.union = ::std::option::Option::Some(file_response::Union::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut FileTransferError {
        if let ::std::option::Option::Some(file_response::Union::Error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Error(FileTransferError::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> FileTransferError {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferError::new()
        }
    }

    // .hbb.FileTransferDone done = 4;

    pub fn done(&self) -> &FileTransferDone {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(ref v)) => v,
            _ => <FileTransferDone as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_done(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_done(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: FileTransferDone) {
        self.union = ::std::option::Option::Some(file_response::Union::Done(v))
    }

    // Mutable pointer to the field.
    pub fn mut_done(&mut self) -> &mut FileTransferDone {
        if let ::std::option::Option::Some(file_response::Union::Done(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Done(FileTransferDone::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_done(&mut self) -> FileTransferDone {
        if self.has_done() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Done(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferDone::new()
        }
    }

    // .hbb.FileTransferDigest digest = 5;

    pub fn digest(&self) -> &FileTransferDigest {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(ref v)) => v,
            _ => <FileTransferDigest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_digest(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: FileTransferDigest) {
        self.union = ::std::option::Option::Some(file_response::Union::Digest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest(&mut self) -> &mut FileTransferDigest {
        if let ::std::option::Option::Some(file_response::Union::Digest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Digest(FileTransferDigest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest(&mut self) -> FileTransferDigest {
        if self.has_digest() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Digest(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferDigest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirectory>(
            "dir",
            FileResponse::has_dir,
            FileResponse::dir,
            FileResponse::mut_dir,
            FileResponse::set_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferBlock>(
            "block",
            FileResponse::has_block,
            FileResponse::block,
            FileResponse::mut_block,
            FileResponse::set_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferError>(
            "error",
            FileResponse::has_error,
            FileResponse::error,
            FileResponse::mut_error,
            FileResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferDone>(
            "done",
            FileResponse::has_done,
            FileResponse::done,
            FileResponse::mut_done,
            FileResponse::set_done,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferDigest>(
            "digest",
            FileResponse::has_digest,
            FileResponse::digest,
            FileResponse::mut_digest,
            FileResponse::set_digest,
        ));
        oneofs.push(file_response::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileResponse>(
            "FileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileResponse {
    const NAME: &'static str = "FileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Dir(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Block(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Error(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Done(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Digest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::Dir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Done(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Digest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::Dir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_response::Union::Block(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_response::Union::Error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_response::Union::Done(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &file_response::Union::Digest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileResponse {
        FileResponse::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileResponse {
        static instance: FileResponse = FileResponse {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileResponse`
pub mod file_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileResponse.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.dir)
        Dir(super::FileDirectory),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.block)
        Block(super::FileTransferBlock),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.error)
        Error(super::FileTransferError),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.done)
        Done(super::FileTransferDone),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.digest)
        Digest(super::FileTransferDigest),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.FileTransferDigest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferDigest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.file_num)
    pub file_num: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.last_modified)
    pub last_modified: u64,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.file_size)
    pub file_size: u64,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.is_upload)
    pub is_upload: bool,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.is_identical)
    pub is_identical: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferDigest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferDigest {
    fn default() -> &'a FileTransferDigest {
        <FileTransferDigest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferDigest {
    pub fn new() -> FileTransferDigest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferDigest| { &m.id },
            |m: &mut FileTransferDigest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferDigest| { &m.file_num },
            |m: &mut FileTransferDigest| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_modified",
            |m: &FileTransferDigest| { &m.last_modified },
            |m: &mut FileTransferDigest| { &mut m.last_modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_size",
            |m: &FileTransferDigest| { &m.file_size },
            |m: &mut FileTransferDigest| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_upload",
            |m: &FileTransferDigest| { &m.is_upload },
            |m: &mut FileTransferDigest| { &mut m.is_upload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_identical",
            |m: &FileTransferDigest| { &m.is_identical },
            |m: &mut FileTransferDigest| { &mut m.is_identical },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferDigest>(
            "FileTransferDigest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferDigest {
    const NAME: &'static str = "FileTransferDigest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                24 => {
                    self.last_modified = is.read_uint64()?;
                },
                32 => {
                    self.file_size = is.read_uint64()?;
                },
                40 => {
                    self.is_upload = is.read_bool()?;
                },
                48 => {
                    self.is_identical = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if self.last_modified != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.last_modified);
        }
        if self.file_size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.file_size);
        }
        if self.is_upload != false {
            my_size += 1 + 1;
        }
        if self.is_identical != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if self.last_modified != 0 {
            os.write_uint64(3, self.last_modified)?;
        }
        if self.file_size != 0 {
            os.write_uint64(4, self.file_size)?;
        }
        if self.is_upload != false {
            os.write_bool(5, self.is_upload)?;
        }
        if self.is_identical != false {
            os.write_bool(6, self.is_identical)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferDigest {
        FileTransferDigest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.last_modified = 0;
        self.file_size = 0;
        self.is_upload = false;
        self.is_identical = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferDigest {
        static instance: FileTransferDigest = FileTransferDigest {
            id: 0,
            file_num: 0,
            last_modified: 0,
            file_size: 0,
            is_upload: false,
            is_identical: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferDigest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferDigest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferDigest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferDigest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransferBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferBlock {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.file_num)
    pub file_num: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.data)
    pub data: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.compressed)
    pub compressed: bool,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.blk_id)
    pub blk_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferBlock {
    fn default() -> &'a FileTransferBlock {
        <FileTransferBlock as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferBlock {
    pub fn new() -> FileTransferBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferBlock| { &m.id },
            |m: &mut FileTransferBlock| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferBlock| { &m.file_num },
            |m: &mut FileTransferBlock| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &FileTransferBlock| { &m.data },
            |m: &mut FileTransferBlock| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compressed",
            |m: &FileTransferBlock| { &m.compressed },
            |m: &mut FileTransferBlock| { &mut m.compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blk_id",
            |m: &FileTransferBlock| { &m.blk_id },
            |m: &mut FileTransferBlock| { &mut m.blk_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferBlock>(
            "FileTransferBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferBlock {
    const NAME: &'static str = "FileTransferBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                26 => {
                    self.data = is.read_tokio_bytes()?;
                },
                32 => {
                    self.compressed = is.read_bool()?;
                },
                40 => {
                    self.blk_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.compressed != false {
            my_size += 1 + 1;
        }
        if self.blk_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.blk_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.compressed != false {
            os.write_bool(4, self.compressed)?;
        }
        if self.blk_id != 0 {
            os.write_uint32(5, self.blk_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferBlock {
        FileTransferBlock::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.data.clear();
        self.compressed = false;
        self.blk_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferBlock {
        static instance: FileTransferBlock = FileTransferBlock {
            id: 0,
            file_num: 0,
            data: ::bytes::Bytes::new(),
            compressed: false,
            blk_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransferError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferError {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferError.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferError.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferError.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferError {
    fn default() -> &'a FileTransferError {
        <FileTransferError as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferError {
    pub fn new() -> FileTransferError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferError| { &m.id },
            |m: &mut FileTransferError| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &FileTransferError| { &m.error },
            |m: &mut FileTransferError| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferError| { &m.file_num },
            |m: &mut FileTransferError| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferError>(
            "FileTransferError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferError {
    const NAME: &'static str = "FileTransferError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferError {
        FileTransferError::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.error.clear();
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferError {
        static instance: FileTransferError = FileTransferError {
            id: 0,
            error: ::std::string::String::new(),
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransferSendRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferSendRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.include_hidden)
    pub include_hidden: bool,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferSendRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferSendRequest {
    fn default() -> &'a FileTransferSendRequest {
        <FileTransferSendRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferSendRequest {
    pub fn new() -> FileTransferSendRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferSendRequest| { &m.id },
            |m: &mut FileTransferSendRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferSendRequest| { &m.path },
            |m: &mut FileTransferSendRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &FileTransferSendRequest| { &m.include_hidden },
            |m: &mut FileTransferSendRequest| { &mut m.include_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferSendRequest| { &m.file_num },
            |m: &mut FileTransferSendRequest| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferSendRequest>(
            "FileTransferSendRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferSendRequest {
    const NAME: &'static str = "FileTransferSendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.include_hidden = is.read_bool()?;
                },
                32 => {
                    self.file_num = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        if self.file_num != 0 {
            os.write_int32(4, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferSendRequest {
        FileTransferSendRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferSendRequest {
        static instance: FileTransferSendRequest = FileTransferSendRequest {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferSendRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferSendRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferSendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferSendRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransferSendConfirmRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferSendConfirmRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferSendConfirmRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferSendConfirmRequest.file_num)
    pub file_num: i32,
    // message oneof groups
    pub union: ::std::option::Option<file_transfer_send_confirm_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferSendConfirmRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferSendConfirmRequest {
    fn default() -> &'a FileTransferSendConfirmRequest {
        <FileTransferSendConfirmRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferSendConfirmRequest {
    pub fn new() -> FileTransferSendConfirmRequest {
        ::std::default::Default::default()
    }

    // bool skip = 3;

    pub fn skip(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(v)) => v,
            _ => false,
        }
    }

    pub fn clear_skip(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_skip(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(v))
    }

    // uint32 offset_blk = 4;

    pub fn offset_blk(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_offset_blk(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_offset_blk(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offset_blk(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferSendConfirmRequest| { &m.id },
            |m: &mut FileTransferSendConfirmRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferSendConfirmRequest| { &m.file_num },
            |m: &mut FileTransferSendConfirmRequest| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "skip",
            FileTransferSendConfirmRequest::has_skip,
            FileTransferSendConfirmRequest::skip,
            FileTransferSendConfirmRequest::set_skip,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "offset_blk",
            FileTransferSendConfirmRequest::has_offset_blk,
            FileTransferSendConfirmRequest::offset_blk,
            FileTransferSendConfirmRequest::set_offset_blk,
        ));
        oneofs.push(file_transfer_send_confirm_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferSendConfirmRequest>(
            "FileTransferSendConfirmRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferSendConfirmRequest {
    const NAME: &'static str = "FileTransferSendConfirmRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                24 => {
                    self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(is.read_bool()?));
                },
                32 => {
                    self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(is.read_uint32()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_transfer_send_confirm_request::Union::Skip(v) => {
                    my_size += 1 + 1;
                },
                &file_transfer_send_confirm_request::Union::OffsetBlk(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_transfer_send_confirm_request::Union::Skip(v) => {
                    os.write_bool(3, v)?;
                },
                &file_transfer_send_confirm_request::Union::OffsetBlk(v) => {
                    os.write_uint32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferSendConfirmRequest {
        FileTransferSendConfirmRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferSendConfirmRequest {
        static instance: FileTransferSendConfirmRequest = FileTransferSendConfirmRequest {
            id: 0,
            file_num: 0,
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferSendConfirmRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferSendConfirmRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferSendConfirmRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferSendConfirmRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileTransferSendConfirmRequest`
pub mod file_transfer_send_confirm_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileTransferSendConfirmRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileTransferSendConfirmRequest.skip)
        Skip(bool),
        // @@protoc_insertion_point(oneof_field:hbb.FileTransferSendConfirmRequest.offset_blk)
        OffsetBlk(u32),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileTransferSendConfirmRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.FileTransferDone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferDone {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferDone.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDone.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferDone.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferDone {
    fn default() -> &'a FileTransferDone {
        <FileTransferDone as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferDone {
    pub fn new() -> FileTransferDone {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferDone| { &m.id },
            |m: &mut FileTransferDone| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferDone| { &m.file_num },
            |m: &mut FileTransferDone| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferDone>(
            "FileTransferDone",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferDone {
    const NAME: &'static str = "FileTransferDone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferDone {
        FileTransferDone::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferDone {
        static instance: FileTransferDone = FileTransferDone {
            id: 0,
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferDone {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferDone").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferDone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferDone {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileTransferReceiveRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileTransferReceiveRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.files)
    pub files: ::std::vec::Vec<FileEntry>,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.file_num)
    pub file_num: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.total_size)
    pub total_size: u64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferReceiveRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferReceiveRequest {
    fn default() -> &'a FileTransferReceiveRequest {
        <FileTransferReceiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferReceiveRequest {
    pub fn new() -> FileTransferReceiveRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferReceiveRequest| { &m.id },
            |m: &mut FileTransferReceiveRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferReceiveRequest| { &m.path },
            |m: &mut FileTransferReceiveRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &FileTransferReceiveRequest| { &m.files },
            |m: &mut FileTransferReceiveRequest| { &mut m.files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferReceiveRequest| { &m.file_num },
            |m: &mut FileTransferReceiveRequest| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_size",
            |m: &FileTransferReceiveRequest| { &m.total_size },
            |m: &mut FileTransferReceiveRequest| { &mut m.total_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferReceiveRequest>(
            "FileTransferReceiveRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferReceiveRequest {
    const NAME: &'static str = "FileTransferReceiveRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.files.push(is.read_message()?);
                },
                32 => {
                    self.file_num = is.read_int32()?;
                },
                40 => {
                    self.total_size = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.file_num != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.file_num);
        }
        if self.total_size != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.total_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.file_num != 0 {
            os.write_int32(4, self.file_num)?;
        }
        if self.total_size != 0 {
            os.write_uint64(5, self.total_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferReceiveRequest {
        FileTransferReceiveRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.files.clear();
        self.file_num = 0;
        self.total_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferReceiveRequest {
        static instance: FileTransferReceiveRequest = FileTransferReceiveRequest {
            id: 0,
            path: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            file_num: 0,
            total_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferReceiveRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferReceiveRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferReceiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferReceiveRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileRemoveDir)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileRemoveDir {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.recursive)
    pub recursive: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileRemoveDir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileRemoveDir {
    fn default() -> &'a FileRemoveDir {
        <FileRemoveDir as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveDir {
    pub fn new() -> FileRemoveDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveDir| { &m.id },
            |m: &mut FileRemoveDir| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveDir| { &m.path },
            |m: &mut FileRemoveDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recursive",
            |m: &FileRemoveDir| { &m.recursive },
            |m: &mut FileRemoveDir| { &mut m.recursive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveDir>(
            "FileRemoveDir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileRemoveDir {
    const NAME: &'static str = "FileRemoveDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.recursive = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.recursive != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.recursive != false {
            os.write_bool(3, self.recursive)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileRemoveDir {
        FileRemoveDir::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.recursive = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileRemoveDir {
        static instance: FileRemoveDir = FileRemoveDir {
            id: 0,
            path: ::std::string::String::new(),
            recursive: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileRemoveDir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileRemoveDir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileRemoveDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveDir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileRemoveFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileRemoveFile {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileRemoveFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileRemoveFile {
    fn default() -> &'a FileRemoveFile {
        <FileRemoveFile as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveFile {
    pub fn new() -> FileRemoveFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveFile| { &m.id },
            |m: &mut FileRemoveFile| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveFile| { &m.path },
            |m: &mut FileRemoveFile| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileRemoveFile| { &m.file_num },
            |m: &mut FileRemoveFile| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveFile>(
            "FileRemoveFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileRemoveFile {
    const NAME: &'static str = "FileRemoveFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileRemoveFile {
        FileRemoveFile::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileRemoveFile {
        static instance: FileRemoveFile = FileRemoveFile {
            id: 0,
            path: ::std::string::String::new(),
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileRemoveFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileRemoveFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileRemoveFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.FileDirCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDirCreate {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileDirCreate.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileDirCreate.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileDirCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDirCreate {
    fn default() -> &'a FileDirCreate {
        <FileDirCreate as ::protobuf::Message>::default_instance()
    }
}

impl FileDirCreate {
    pub fn new() -> FileDirCreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirCreate| { &m.id },
            |m: &mut FileDirCreate| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirCreate| { &m.path },
            |m: &mut FileDirCreate| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirCreate>(
            "FileDirCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDirCreate {
    const NAME: &'static str = "FileDirCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDirCreate {
        FileDirCreate::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDirCreate {
        static instance: FileDirCreate = FileDirCreate {
            id: 0,
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDirCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDirCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDirCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrMonitorReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrMonitorReady {
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrMonitorReady.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrMonitorReady {
    fn default() -> &'a CliprdrMonitorReady {
        <CliprdrMonitorReady as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrMonitorReady {
    pub fn new() -> CliprdrMonitorReady {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrMonitorReady>(
            "CliprdrMonitorReady",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrMonitorReady {
    const NAME: &'static str = "CliprdrMonitorReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrMonitorReady {
        CliprdrMonitorReady::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrMonitorReady {
        static instance: CliprdrMonitorReady = CliprdrMonitorReady {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrMonitorReady {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrMonitorReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrMonitorReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrMonitorReady {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrFormat {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFormat.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFormat.format)
    pub format: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFormat {
    fn default() -> &'a CliprdrFormat {
        <CliprdrFormat as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFormat {
    pub fn new() -> CliprdrFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CliprdrFormat| { &m.id },
            |m: &mut CliprdrFormat| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &CliprdrFormat| { &m.format },
            |m: &mut CliprdrFormat| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFormat>(
            "CliprdrFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFormat {
    const NAME: &'static str = "CliprdrFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.id = is.read_int32()?;
                },
                26 => {
                    self.format = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.id);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.format.is_empty() {
            os.write_string(3, &self.format)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFormat {
        CliprdrFormat::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFormat {
        static instance: CliprdrFormat = CliprdrFormat {
            id: 0,
            format: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrServerFormatList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrServerFormatList {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatList.formats)
    pub formats: ::std::vec::Vec<CliprdrFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatList {
    fn default() -> &'a CliprdrServerFormatList {
        <CliprdrServerFormatList as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatList {
    pub fn new() -> CliprdrServerFormatList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "formats",
            |m: &CliprdrServerFormatList| { &m.formats },
            |m: &mut CliprdrServerFormatList| { &mut m.formats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatList>(
            "CliprdrServerFormatList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatList {
    const NAME: &'static str = "CliprdrServerFormatList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.formats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.formats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatList {
        CliprdrServerFormatList::new()
    }

    fn clear(&mut self) {
        self.formats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatList {
        static instance: CliprdrServerFormatList = CliprdrServerFormatList {
            formats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrServerFormatListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrServerFormatListResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatListResponse.msg_flags)
    pub msg_flags: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatListResponse {
    fn default() -> &'a CliprdrServerFormatListResponse {
        <CliprdrServerFormatListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatListResponse {
    pub fn new() -> CliprdrServerFormatListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrServerFormatListResponse| { &m.msg_flags },
            |m: &mut CliprdrServerFormatListResponse| { &mut m.msg_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatListResponse>(
            "CliprdrServerFormatListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatListResponse {
    const NAME: &'static str = "CliprdrServerFormatListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.msg_flags = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.msg_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(2, self.msg_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatListResponse {
        CliprdrServerFormatListResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatListResponse {
        static instance: CliprdrServerFormatListResponse = CliprdrServerFormatListResponse {
            msg_flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrServerFormatDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrServerFormatDataRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataRequest.requested_format_id)
    pub requested_format_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatDataRequest {
    fn default() -> &'a CliprdrServerFormatDataRequest {
        <CliprdrServerFormatDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatDataRequest {
    pub fn new() -> CliprdrServerFormatDataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requested_format_id",
            |m: &CliprdrServerFormatDataRequest| { &m.requested_format_id },
            |m: &mut CliprdrServerFormatDataRequest| { &mut m.requested_format_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatDataRequest>(
            "CliprdrServerFormatDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatDataRequest {
    const NAME: &'static str = "CliprdrServerFormatDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.requested_format_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.requested_format_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.requested_format_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.requested_format_id != 0 {
            os.write_int32(2, self.requested_format_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatDataRequest {
        CliprdrServerFormatDataRequest::new()
    }

    fn clear(&mut self) {
        self.requested_format_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatDataRequest {
        static instance: CliprdrServerFormatDataRequest = CliprdrServerFormatDataRequest {
            requested_format_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrServerFormatDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrServerFormatDataResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataResponse.msg_flags)
    pub msg_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataResponse.format_data)
    pub format_data: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatDataResponse {
    fn default() -> &'a CliprdrServerFormatDataResponse {
        <CliprdrServerFormatDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatDataResponse {
    pub fn new() -> CliprdrServerFormatDataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrServerFormatDataResponse| { &m.msg_flags },
            |m: &mut CliprdrServerFormatDataResponse| { &mut m.msg_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format_data",
            |m: &CliprdrServerFormatDataResponse| { &m.format_data },
            |m: &mut CliprdrServerFormatDataResponse| { &mut m.format_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatDataResponse>(
            "CliprdrServerFormatDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatDataResponse {
    const NAME: &'static str = "CliprdrServerFormatDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.msg_flags = is.read_int32()?;
                },
                26 => {
                    self.format_data = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.msg_flags);
        }
        if !self.format_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.format_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(2, self.msg_flags)?;
        }
        if !self.format_data.is_empty() {
            os.write_bytes(3, &self.format_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatDataResponse {
        CliprdrServerFormatDataResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.format_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatDataResponse {
        static instance: CliprdrServerFormatDataResponse = CliprdrServerFormatDataResponse {
            msg_flags: 0,
            format_data: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrFileContentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrFileContentsRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.stream_id)
    pub stream_id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.list_index)
    pub list_index: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.dw_flags)
    pub dw_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.n_position_low)
    pub n_position_low: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.n_position_high)
    pub n_position_high: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.cb_requested)
    pub cb_requested: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.have_clip_data_id)
    pub have_clip_data_id: bool,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.clip_data_id)
    pub clip_data_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFileContentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFileContentsRequest {
    fn default() -> &'a CliprdrFileContentsRequest {
        <CliprdrFileContentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFileContentsRequest {
    pub fn new() -> CliprdrFileContentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_id",
            |m: &CliprdrFileContentsRequest| { &m.stream_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.stream_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_index",
            |m: &CliprdrFileContentsRequest| { &m.list_index },
            |m: &mut CliprdrFileContentsRequest| { &mut m.list_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dw_flags",
            |m: &CliprdrFileContentsRequest| { &m.dw_flags },
            |m: &mut CliprdrFileContentsRequest| { &mut m.dw_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_position_low",
            |m: &CliprdrFileContentsRequest| { &m.n_position_low },
            |m: &mut CliprdrFileContentsRequest| { &mut m.n_position_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_position_high",
            |m: &CliprdrFileContentsRequest| { &m.n_position_high },
            |m: &mut CliprdrFileContentsRequest| { &mut m.n_position_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cb_requested",
            |m: &CliprdrFileContentsRequest| { &m.cb_requested },
            |m: &mut CliprdrFileContentsRequest| { &mut m.cb_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "have_clip_data_id",
            |m: &CliprdrFileContentsRequest| { &m.have_clip_data_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.have_clip_data_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clip_data_id",
            |m: &CliprdrFileContentsRequest| { &m.clip_data_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.clip_data_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFileContentsRequest>(
            "CliprdrFileContentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFileContentsRequest {
    const NAME: &'static str = "CliprdrFileContentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.stream_id = is.read_int32()?;
                },
                24 => {
                    self.list_index = is.read_int32()?;
                },
                32 => {
                    self.dw_flags = is.read_int32()?;
                },
                40 => {
                    self.n_position_low = is.read_int32()?;
                },
                48 => {
                    self.n_position_high = is.read_int32()?;
                },
                56 => {
                    self.cb_requested = is.read_int32()?;
                },
                64 => {
                    self.have_clip_data_id = is.read_bool()?;
                },
                72 => {
                    self.clip_data_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.stream_id);
        }
        if self.list_index != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.list_index);
        }
        if self.dw_flags != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.dw_flags);
        }
        if self.n_position_low != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.n_position_low);
        }
        if self.n_position_high != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.n_position_high);
        }
        if self.cb_requested != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.cb_requested);
        }
        if self.have_clip_data_id != false {
            my_size += 1 + 1;
        }
        if self.clip_data_id != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.clip_data_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.stream_id != 0 {
            os.write_int32(2, self.stream_id)?;
        }
        if self.list_index != 0 {
            os.write_int32(3, self.list_index)?;
        }
        if self.dw_flags != 0 {
            os.write_int32(4, self.dw_flags)?;
        }
        if self.n_position_low != 0 {
            os.write_int32(5, self.n_position_low)?;
        }
        if self.n_position_high != 0 {
            os.write_int32(6, self.n_position_high)?;
        }
        if self.cb_requested != 0 {
            os.write_int32(7, self.cb_requested)?;
        }
        if self.have_clip_data_id != false {
            os.write_bool(8, self.have_clip_data_id)?;
        }
        if self.clip_data_id != 0 {
            os.write_int32(9, self.clip_data_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFileContentsRequest {
        CliprdrFileContentsRequest::new()
    }

    fn clear(&mut self) {
        self.stream_id = 0;
        self.list_index = 0;
        self.dw_flags = 0;
        self.n_position_low = 0;
        self.n_position_high = 0;
        self.cb_requested = 0;
        self.have_clip_data_id = false;
        self.clip_data_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFileContentsRequest {
        static instance: CliprdrFileContentsRequest = CliprdrFileContentsRequest {
            stream_id: 0,
            list_index: 0,
            dw_flags: 0,
            n_position_low: 0,
            n_position_high: 0,
            cb_requested: 0,
            have_clip_data_id: false,
            clip_data_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFileContentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFileContentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFileContentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFileContentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CliprdrFileContentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CliprdrFileContentsResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.msg_flags)
    pub msg_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.stream_id)
    pub stream_id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.requested_data)
    pub requested_data: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFileContentsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFileContentsResponse {
    fn default() -> &'a CliprdrFileContentsResponse {
        <CliprdrFileContentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFileContentsResponse {
    pub fn new() -> CliprdrFileContentsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrFileContentsResponse| { &m.msg_flags },
            |m: &mut CliprdrFileContentsResponse| { &mut m.msg_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_id",
            |m: &CliprdrFileContentsResponse| { &m.stream_id },
            |m: &mut CliprdrFileContentsResponse| { &mut m.stream_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requested_data",
            |m: &CliprdrFileContentsResponse| { &m.requested_data },
            |m: &mut CliprdrFileContentsResponse| { &mut m.requested_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFileContentsResponse>(
            "CliprdrFileContentsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFileContentsResponse {
    const NAME: &'static str = "CliprdrFileContentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.msg_flags = is.read_int32()?;
                },
                32 => {
                    self.stream_id = is.read_int32()?;
                },
                42 => {
                    self.requested_data = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.msg_flags);
        }
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.stream_id);
        }
        if !self.requested_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.requested_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(3, self.msg_flags)?;
        }
        if self.stream_id != 0 {
            os.write_int32(4, self.stream_id)?;
        }
        if !self.requested_data.is_empty() {
            os.write_bytes(5, &self.requested_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFileContentsResponse {
        CliprdrFileContentsResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.stream_id = 0;
        self.requested_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFileContentsResponse {
        static instance: CliprdrFileContentsResponse = CliprdrFileContentsResponse {
            msg_flags: 0,
            stream_id: 0,
            requested_data: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFileContentsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFileContentsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFileContentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFileContentsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Cliprdr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cliprdr {
    // message oneof groups
    pub union: ::std::option::Option<cliprdr::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Cliprdr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cliprdr {
    fn default() -> &'a Cliprdr {
        <Cliprdr as ::protobuf::Message>::default_instance()
    }
}

impl Cliprdr {
    pub fn new() -> Cliprdr {
        ::std::default::Default::default()
    }

    // .hbb.CliprdrMonitorReady ready = 1;

    pub fn ready(&self) -> &CliprdrMonitorReady {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(ref v)) => v,
            _ => <CliprdrMonitorReady as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ready(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: CliprdrMonitorReady) {
        self.union = ::std::option::Option::Some(cliprdr::Union::Ready(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ready(&mut self) -> &mut CliprdrMonitorReady {
        if let ::std::option::Option::Some(cliprdr::Union::Ready(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::Ready(CliprdrMonitorReady::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ready(&mut self) -> CliprdrMonitorReady {
        if self.has_ready() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::Ready(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrMonitorReady::new()
        }
    }

    // .hbb.CliprdrServerFormatList format_list = 2;

    pub fn format_list(&self) -> &CliprdrServerFormatList {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(ref v)) => v,
            _ => <CliprdrServerFormatList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_list(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_list(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_list(&mut self, v: CliprdrServerFormatList) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_list(&mut self) -> &mut CliprdrServerFormatList {
        if let ::std::option::Option::Some(cliprdr::Union::FormatList(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(CliprdrServerFormatList::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_list(&mut self) -> CliprdrServerFormatList {
        if self.has_format_list() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatList(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatList::new()
        }
    }

    // .hbb.CliprdrServerFormatListResponse format_list_response = 3;

    pub fn format_list_response(&self) -> &CliprdrServerFormatListResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(ref v)) => v,
            _ => <CliprdrServerFormatListResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_list_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_list_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_list_response(&mut self, v: CliprdrServerFormatListResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_list_response(&mut self) -> &mut CliprdrServerFormatListResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FormatListResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(CliprdrServerFormatListResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_list_response(&mut self) -> CliprdrServerFormatListResponse {
        if self.has_format_list_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatListResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatListResponse::new()
        }
    }

    // .hbb.CliprdrServerFormatDataRequest format_data_request = 4;

    pub fn format_data_request(&self) -> &CliprdrServerFormatDataRequest {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(ref v)) => v,
            _ => <CliprdrServerFormatDataRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_data_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_data_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_data_request(&mut self, v: CliprdrServerFormatDataRequest) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_data_request(&mut self) -> &mut CliprdrServerFormatDataRequest {
        if let ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(CliprdrServerFormatDataRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_data_request(&mut self) -> CliprdrServerFormatDataRequest {
        if self.has_format_data_request() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatDataRequest::new()
        }
    }

    // .hbb.CliprdrServerFormatDataResponse format_data_response = 5;

    pub fn format_data_response(&self) -> &CliprdrServerFormatDataResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(ref v)) => v,
            _ => <CliprdrServerFormatDataResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_data_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_data_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_data_response(&mut self, v: CliprdrServerFormatDataResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_data_response(&mut self) -> &mut CliprdrServerFormatDataResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(CliprdrServerFormatDataResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_data_response(&mut self) -> CliprdrServerFormatDataResponse {
        if self.has_format_data_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatDataResponse::new()
        }
    }

    // .hbb.CliprdrFileContentsRequest file_contents_request = 6;

    pub fn file_contents_request(&self) -> &CliprdrFileContentsRequest {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(ref v)) => v,
            _ => <CliprdrFileContentsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_contents_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_contents_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_contents_request(&mut self, v: CliprdrFileContentsRequest) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_contents_request(&mut self) -> &mut CliprdrFileContentsRequest {
        if let ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(CliprdrFileContentsRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_contents_request(&mut self) -> CliprdrFileContentsRequest {
        if self.has_file_contents_request() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrFileContentsRequest::new()
        }
    }

    // .hbb.CliprdrFileContentsResponse file_contents_response = 7;

    pub fn file_contents_response(&self) -> &CliprdrFileContentsResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(ref v)) => v,
            _ => <CliprdrFileContentsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_contents_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_contents_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_contents_response(&mut self, v: CliprdrFileContentsResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_contents_response(&mut self) -> &mut CliprdrFileContentsResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(CliprdrFileContentsResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_contents_response(&mut self) -> CliprdrFileContentsResponse {
        if self.has_file_contents_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrFileContentsResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrMonitorReady>(
            "ready",
            Cliprdr::has_ready,
            Cliprdr::ready,
            Cliprdr::mut_ready,
            Cliprdr::set_ready,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatList>(
            "format_list",
            Cliprdr::has_format_list,
            Cliprdr::format_list,
            Cliprdr::mut_format_list,
            Cliprdr::set_format_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatListResponse>(
            "format_list_response",
            Cliprdr::has_format_list_response,
            Cliprdr::format_list_response,
            Cliprdr::mut_format_list_response,
            Cliprdr::set_format_list_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatDataRequest>(
            "format_data_request",
            Cliprdr::has_format_data_request,
            Cliprdr::format_data_request,
            Cliprdr::mut_format_data_request,
            Cliprdr::set_format_data_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatDataResponse>(
            "format_data_response",
            Cliprdr::has_format_data_response,
            Cliprdr::format_data_response,
            Cliprdr::mut_format_data_response,
            Cliprdr::set_format_data_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrFileContentsRequest>(
            "file_contents_request",
            Cliprdr::has_file_contents_request,
            Cliprdr::file_contents_request,
            Cliprdr::mut_file_contents_request,
            Cliprdr::set_file_contents_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrFileContentsResponse>(
            "file_contents_response",
            Cliprdr::has_file_contents_response,
            Cliprdr::file_contents_response,
            Cliprdr::mut_file_contents_response,
            Cliprdr::set_file_contents_response,
        ));
        oneofs.push(cliprdr::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cliprdr>(
            "Cliprdr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cliprdr {
    const NAME: &'static str = "Cliprdr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::Ready(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &cliprdr::Union::Ready(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatListResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatDataRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatDataResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FileContentsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FileContentsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &cliprdr::Union::Ready(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cliprdr::Union::FormatList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cliprdr::Union::FormatListResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cliprdr::Union::FormatDataRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &cliprdr::Union::FormatDataResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cliprdr::Union::FileContentsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &cliprdr::Union::FileContentsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cliprdr {
        Cliprdr::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cliprdr {
        static instance: Cliprdr = Cliprdr {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cliprdr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cliprdr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cliprdr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cliprdr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Cliprdr`
pub mod cliprdr {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Cliprdr.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.ready)
        Ready(super::CliprdrMonitorReady),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_list)
        FormatList(super::CliprdrServerFormatList),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_list_response)
        FormatListResponse(super::CliprdrServerFormatListResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_data_request)
        FormatDataRequest(super::CliprdrServerFormatDataRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_data_response)
        FormatDataResponse(super::CliprdrServerFormatDataResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.file_contents_request)
        FileContentsRequest(super::CliprdrFileContentsRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.file_contents_response)
        FileContentsResponse(super::CliprdrFileContentsResponse),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Cliprdr as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.Resolution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Resolution {
    // message fields
    // @@protoc_insertion_point(field:hbb.Resolution.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.Resolution.height)
    pub height: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Resolution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Resolution {
    fn default() -> &'a Resolution {
        <Resolution as ::protobuf::Message>::default_instance()
    }
}

impl Resolution {
    pub fn new() -> Resolution {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &Resolution| { &m.width },
            |m: &mut Resolution| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Resolution| { &m.height },
            |m: &mut Resolution| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Resolution>(
            "Resolution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Resolution {
    const NAME: &'static str = "Resolution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_int32()?;
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Resolution {
        Resolution::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Resolution {
        static instance: Resolution = Resolution {
            width: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Resolution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Resolution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Resolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resolution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.DisplayResolution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisplayResolution {
    // message fields
    // @@protoc_insertion_point(field:hbb.DisplayResolution.display)
    pub display: i32,
    // @@protoc_insertion_point(field:hbb.DisplayResolution.resolution)
    pub resolution: ::protobuf::MessageField<Resolution>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.DisplayResolution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayResolution {
    fn default() -> &'a DisplayResolution {
        <DisplayResolution as ::protobuf::Message>::default_instance()
    }
}

impl DisplayResolution {
    pub fn new() -> DisplayResolution {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &DisplayResolution| { &m.display },
            |m: &mut DisplayResolution| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Resolution>(
            "resolution",
            |m: &DisplayResolution| { &m.resolution },
            |m: &mut DisplayResolution| { &mut m.resolution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayResolution>(
            "DisplayResolution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayResolution {
    const NAME: &'static str = "DisplayResolution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resolution)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.display);
        }
        if let Some(v) = self.resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.display != 0 {
            os.write_int32(1, self.display)?;
        }
        if let Some(v) = self.resolution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayResolution {
        DisplayResolution::new()
    }

    fn clear(&mut self) {
        self.display = 0;
        self.resolution.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayResolution {
        static instance: DisplayResolution = DisplayResolution {
            display: 0,
            resolution: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayResolution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayResolution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayResolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayResolution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SupportedResolutions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SupportedResolutions {
    // message fields
    // @@protoc_insertion_point(field:hbb.SupportedResolutions.resolutions)
    pub resolutions: ::std::vec::Vec<Resolution>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SupportedResolutions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SupportedResolutions {
    fn default() -> &'a SupportedResolutions {
        <SupportedResolutions as ::protobuf::Message>::default_instance()
    }
}

impl SupportedResolutions {
    pub fn new() -> SupportedResolutions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resolutions",
            |m: &SupportedResolutions| { &m.resolutions },
            |m: &mut SupportedResolutions| { &mut m.resolutions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SupportedResolutions>(
            "SupportedResolutions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SupportedResolutions {
    const NAME: &'static str = "SupportedResolutions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resolutions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resolutions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resolutions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SupportedResolutions {
        SupportedResolutions::new()
    }

    fn clear(&mut self) {
        self.resolutions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SupportedResolutions {
        static instance: SupportedResolutions = SupportedResolutions {
            resolutions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SupportedResolutions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SupportedResolutions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SupportedResolutions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedResolutions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SwitchDisplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchDisplay {
    // message fields
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.display)
    pub display: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.cursor_embedded)
    pub cursor_embedded: bool,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.resolutions)
    pub resolutions: ::protobuf::MessageField<SupportedResolutions>,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.original_resolution)
    pub original_resolution: ::protobuf::MessageField<Resolution>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SwitchDisplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchDisplay {
    fn default() -> &'a SwitchDisplay {
        <SwitchDisplay as ::protobuf::Message>::default_instance()
    }
}

impl SwitchDisplay {
    pub fn new() -> SwitchDisplay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &SwitchDisplay| { &m.display },
            |m: &mut SwitchDisplay| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &SwitchDisplay| { &m.x },
            |m: &mut SwitchDisplay| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &SwitchDisplay| { &m.y },
            |m: &mut SwitchDisplay| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &SwitchDisplay| { &m.width },
            |m: &mut SwitchDisplay| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &SwitchDisplay| { &m.height },
            |m: &mut SwitchDisplay| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor_embedded",
            |m: &SwitchDisplay| { &m.cursor_embedded },
            |m: &mut SwitchDisplay| { &mut m.cursor_embedded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SupportedResolutions>(
            "resolutions",
            |m: &SwitchDisplay| { &m.resolutions },
            |m: &mut SwitchDisplay| { &mut m.resolutions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Resolution>(
            "original_resolution",
            |m: &SwitchDisplay| { &m.original_resolution },
            |m: &mut SwitchDisplay| { &mut m.original_resolution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchDisplay>(
            "SwitchDisplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchDisplay {
    const NAME: &'static str = "SwitchDisplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display = is.read_int32()?;
                },
                16 => {
                    self.x = is.read_sint32()?;
                },
                24 => {
                    self.y = is.read_sint32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.height = is.read_int32()?;
                },
                48 => {
                    self.cursor_embedded = is.read_bool()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resolutions)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_resolution)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.display);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.height);
        }
        if self.cursor_embedded != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.resolutions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.original_resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.display != 0 {
            os.write_int32(1, self.display)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        if self.cursor_embedded != false {
            os.write_bool(6, self.cursor_embedded)?;
        }
        if let Some(v) = self.resolutions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.original_resolution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchDisplay {
        SwitchDisplay::new()
    }

    fn clear(&mut self) {
        self.display = 0;
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.cursor_embedded = false;
        self.resolutions.clear();
        self.original_resolution.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchDisplay {
        static instance: SwitchDisplay = SwitchDisplay {
            display: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            cursor_embedded: false,
            resolutions: ::protobuf::MessageField::none(),
            original_resolution: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchDisplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchDisplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchDisplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.CaptureDisplays)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CaptureDisplays {
    // message fields
    // @@protoc_insertion_point(field:hbb.CaptureDisplays.add)
    pub add: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:hbb.CaptureDisplays.sub)
    pub sub: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:hbb.CaptureDisplays.set)
    pub set: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CaptureDisplays.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CaptureDisplays {
    fn default() -> &'a CaptureDisplays {
        <CaptureDisplays as ::protobuf::Message>::default_instance()
    }
}

impl CaptureDisplays {
    pub fn new() -> CaptureDisplays {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "add",
            |m: &CaptureDisplays| { &m.add },
            |m: &mut CaptureDisplays| { &mut m.add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub",
            |m: &CaptureDisplays| { &m.sub },
            |m: &mut CaptureDisplays| { &mut m.sub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "set",
            |m: &CaptureDisplays| { &m.set },
            |m: &mut CaptureDisplays| { &mut m.set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CaptureDisplays>(
            "CaptureDisplays",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CaptureDisplays {
    const NAME: &'static str = "CaptureDisplays";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.add)?;
                },
                8 => {
                    self.add.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.sub)?;
                },
                16 => {
                    self.sub.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.set)?;
                },
                24 => {
                    self.set.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.add);
        my_size += ::protobuf::rt::vec_packed_int32_size(2, &self.sub);
        my_size += ::protobuf::rt::vec_packed_int32_size(3, &self.set);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_int32(1, &self.add)?;
        os.write_repeated_packed_int32(2, &self.sub)?;
        os.write_repeated_packed_int32(3, &self.set)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CaptureDisplays {
        CaptureDisplays::new()
    }

    fn clear(&mut self) {
        self.add.clear();
        self.sub.clear();
        self.set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CaptureDisplays {
        static instance: CaptureDisplays = CaptureDisplays {
            add: ::std::vec::Vec::new(),
            sub: ::std::vec::Vec::new(),
            set: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CaptureDisplays {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CaptureDisplays").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CaptureDisplays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaptureDisplays {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.ToggleVirtualDisplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ToggleVirtualDisplay {
    // message fields
    // @@protoc_insertion_point(field:hbb.ToggleVirtualDisplay.display)
    pub display: i32,
    // @@protoc_insertion_point(field:hbb.ToggleVirtualDisplay.on)
    pub on: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ToggleVirtualDisplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ToggleVirtualDisplay {
    fn default() -> &'a ToggleVirtualDisplay {
        <ToggleVirtualDisplay as ::protobuf::Message>::default_instance()
    }
}

impl ToggleVirtualDisplay {
    pub fn new() -> ToggleVirtualDisplay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &ToggleVirtualDisplay| { &m.display },
            |m: &mut ToggleVirtualDisplay| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "on",
            |m: &ToggleVirtualDisplay| { &m.on },
            |m: &mut ToggleVirtualDisplay| { &mut m.on },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ToggleVirtualDisplay>(
            "ToggleVirtualDisplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ToggleVirtualDisplay {
    const NAME: &'static str = "ToggleVirtualDisplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display = is.read_int32()?;
                },
                16 => {
                    self.on = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.display);
        }
        if self.on != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.display != 0 {
            os.write_int32(1, self.display)?;
        }
        if self.on != false {
            os.write_bool(2, self.on)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ToggleVirtualDisplay {
        ToggleVirtualDisplay::new()
    }

    fn clear(&mut self) {
        self.display = 0;
        self.on = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ToggleVirtualDisplay {
        static instance: ToggleVirtualDisplay = ToggleVirtualDisplay {
            display: 0,
            on: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ToggleVirtualDisplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ToggleVirtualDisplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ToggleVirtualDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ToggleVirtualDisplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.TogglePrivacyMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TogglePrivacyMode {
    // message fields
    // @@protoc_insertion_point(field:hbb.TogglePrivacyMode.impl_key)
    pub impl_key: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.TogglePrivacyMode.on)
    pub on: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TogglePrivacyMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TogglePrivacyMode {
    fn default() -> &'a TogglePrivacyMode {
        <TogglePrivacyMode as ::protobuf::Message>::default_instance()
    }
}

impl TogglePrivacyMode {
    pub fn new() -> TogglePrivacyMode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "impl_key",
            |m: &TogglePrivacyMode| { &m.impl_key },
            |m: &mut TogglePrivacyMode| { &mut m.impl_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "on",
            |m: &TogglePrivacyMode| { &m.on },
            |m: &mut TogglePrivacyMode| { &mut m.on },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TogglePrivacyMode>(
            "TogglePrivacyMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TogglePrivacyMode {
    const NAME: &'static str = "TogglePrivacyMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.impl_key = is.read_string()?;
                },
                16 => {
                    self.on = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.impl_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.impl_key);
        }
        if self.on != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.impl_key.is_empty() {
            os.write_string(1, &self.impl_key)?;
        }
        if self.on != false {
            os.write_bool(2, self.on)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TogglePrivacyMode {
        TogglePrivacyMode::new()
    }

    fn clear(&mut self) {
        self.impl_key.clear();
        self.on = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TogglePrivacyMode {
        static instance: TogglePrivacyMode = TogglePrivacyMode {
            impl_key: ::std::string::String::new(),
            on: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TogglePrivacyMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TogglePrivacyMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TogglePrivacyMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TogglePrivacyMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PermissionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.PermissionInfo.permission)
    pub permission: ::protobuf::EnumOrUnknown<permission_info::Permission>,
    // @@protoc_insertion_point(field:hbb.PermissionInfo.enabled)
    pub enabled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PermissionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionInfo {
    fn default() -> &'a PermissionInfo {
        <PermissionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PermissionInfo {
    pub fn new() -> PermissionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission",
            |m: &PermissionInfo| { &m.permission },
            |m: &mut PermissionInfo| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &PermissionInfo| { &m.enabled },
            |m: &mut PermissionInfo| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionInfo>(
            "PermissionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionInfo {
    const NAME: &'static str = "PermissionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.enabled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.permission != ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard) {
            my_size += ::protobuf::rt::int32_size(1, self.permission.value());
        }
        if self.enabled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.permission != ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.permission))?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionInfo {
        PermissionInfo::new()
    }

    fn clear(&mut self) {
        self.permission = ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard);
        self.enabled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionInfo {
        static instance: PermissionInfo = PermissionInfo {
            permission: ::protobuf::EnumOrUnknown::from_i32(0),
            enabled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PermissionInfo`
pub mod permission_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.PermissionInfo.Permission)
    pub enum Permission {
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Keyboard)
        Keyboard = 0,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Clipboard)
        Clipboard = 2,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Audio)
        Audio = 3,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.File)
        File = 4,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Restart)
        Restart = 5,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Recording)
        Recording = 6,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.BlockInput)
        BlockInput = 7,
    }

    impl ::protobuf::Enum for Permission {
        const NAME: &'static str = "Permission";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Permission> {
            match value {
                0 => ::std::option::Option::Some(Permission::Keyboard),
                2 => ::std::option::Option::Some(Permission::Clipboard),
                3 => ::std::option::Option::Some(Permission::Audio),
                4 => ::std::option::Option::Some(Permission::File),
                5 => ::std::option::Option::Some(Permission::Restart),
                6 => ::std::option::Option::Some(Permission::Recording),
                7 => ::std::option::Option::Some(Permission::BlockInput),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Permission> {
            match str {
                "Keyboard" => ::std::option::Option::Some(Permission::Keyboard),
                "Clipboard" => ::std::option::Option::Some(Permission::Clipboard),
                "Audio" => ::std::option::Option::Some(Permission::Audio),
                "File" => ::std::option::Option::Some(Permission::File),
                "Restart" => ::std::option::Option::Some(Permission::Restart),
                "Recording" => ::std::option::Option::Some(Permission::Recording),
                "BlockInput" => ::std::option::Option::Some(Permission::BlockInput),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Permission] = &[
            Permission::Keyboard,
            Permission::Clipboard,
            Permission::Audio,
            Permission::File,
            Permission::Restart,
            Permission::Recording,
            Permission::BlockInput,
        ];
    }

    impl ::protobuf::EnumFull for Permission {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PermissionInfo.Permission").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Permission::Keyboard => 0,
                Permission::Clipboard => 1,
                Permission::Audio => 2,
                Permission::File => 3,
                Permission::Restart => 4,
                Permission::Recording => 5,
                Permission::BlockInput => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Permission {
        fn default() -> Self {
            Permission::Keyboard
        }
    }

    impl Permission {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Permission>("PermissionInfo.Permission")
        }
    }
}

// @@protoc_insertion_point(message:hbb.SupportedDecoding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SupportedDecoding {
    // message fields
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.ability_vp9)
    pub ability_vp9: i32,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.ability_h264)
    pub ability_h264: i32,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.ability_h265)
    pub ability_h265: i32,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.prefer)
    pub prefer: ::protobuf::EnumOrUnknown<supported_decoding::PreferCodec>,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.ability_vp8)
    pub ability_vp8: i32,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.ability_av1)
    pub ability_av1: i32,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.i444)
    pub i444: ::protobuf::MessageField<CodecAbility>,
    // @@protoc_insertion_point(field:hbb.SupportedDecoding.prefer_chroma)
    pub prefer_chroma: ::protobuf::EnumOrUnknown<Chroma>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SupportedDecoding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SupportedDecoding {
    fn default() -> &'a SupportedDecoding {
        <SupportedDecoding as ::protobuf::Message>::default_instance()
    }
}

impl SupportedDecoding {
    pub fn new() -> SupportedDecoding {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ability_vp9",
            |m: &SupportedDecoding| { &m.ability_vp9 },
            |m: &mut SupportedDecoding| { &mut m.ability_vp9 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ability_h264",
            |m: &SupportedDecoding| { &m.ability_h264 },
            |m: &mut SupportedDecoding| { &mut m.ability_h264 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ability_h265",
            |m: &SupportedDecoding| { &m.ability_h265 },
            |m: &mut SupportedDecoding| { &mut m.ability_h265 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefer",
            |m: &SupportedDecoding| { &m.prefer },
            |m: &mut SupportedDecoding| { &mut m.prefer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ability_vp8",
            |m: &SupportedDecoding| { &m.ability_vp8 },
            |m: &mut SupportedDecoding| { &mut m.ability_vp8 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ability_av1",
            |m: &SupportedDecoding| { &m.ability_av1 },
            |m: &mut SupportedDecoding| { &mut m.ability_av1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CodecAbility>(
            "i444",
            |m: &SupportedDecoding| { &m.i444 },
            |m: &mut SupportedDecoding| { &mut m.i444 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefer_chroma",
            |m: &SupportedDecoding| { &m.prefer_chroma },
            |m: &mut SupportedDecoding| { &mut m.prefer_chroma },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SupportedDecoding>(
            "SupportedDecoding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SupportedDecoding {
    const NAME: &'static str = "SupportedDecoding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_vp9 = is.read_int32()?;
                },
                16 => {
                    self.ability_h264 = is.read_int32()?;
                },
                24 => {
                    self.ability_h265 = is.read_int32()?;
                },
                32 => {
                    self.prefer = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.ability_vp8 = is.read_int32()?;
                },
                48 => {
                    self.ability_av1 = is.read_int32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.i444)?;
                },
                64 => {
                    self.prefer_chroma = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ability_vp9 != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ability_vp9);
        }
        if self.ability_h264 != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.ability_h264);
        }
        if self.ability_h265 != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.ability_h265);
        }
        if self.prefer != ::protobuf::EnumOrUnknown::new(supported_decoding::PreferCodec::Auto) {
            my_size += ::protobuf::rt::int32_size(4, self.prefer.value());
        }
        if self.ability_vp8 != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.ability_vp8);
        }
        if self.ability_av1 != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.ability_av1);
        }
        if let Some(v) = self.i444.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.prefer_chroma != ::protobuf::EnumOrUnknown::new(Chroma::I420) {
            my_size += ::protobuf::rt::int32_size(8, self.prefer_chroma.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ability_vp9 != 0 {
            os.write_int32(1, self.ability_vp9)?;
        }
        if self.ability_h264 != 0 {
            os.write_int32(2, self.ability_h264)?;
        }
        if self.ability_h265 != 0 {
            os.write_int32(3, self.ability_h265)?;
        }
        if self.prefer != ::protobuf::EnumOrUnknown::new(supported_decoding::PreferCodec::Auto) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.prefer))?;
        }
        if self.ability_vp8 != 0 {
            os.write_int32(5, self.ability_vp8)?;
        }
        if self.ability_av1 != 0 {
            os.write_int32(6, self.ability_av1)?;
        }
        if let Some(v) = self.i444.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.prefer_chroma != ::protobuf::EnumOrUnknown::new(Chroma::I420) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.prefer_chroma))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SupportedDecoding {
        SupportedDecoding::new()
    }

    fn clear(&mut self) {
        self.ability_vp9 = 0;
        self.ability_h264 = 0;
        self.ability_h265 = 0;
        self.prefer = ::protobuf::EnumOrUnknown::new(supported_decoding::PreferCodec::Auto);
        self.ability_vp8 = 0;
        self.ability_av1 = 0;
        self.i444.clear();
        self.prefer_chroma = ::protobuf::EnumOrUnknown::new(Chroma::I420);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SupportedDecoding {
        static instance: SupportedDecoding = SupportedDecoding {
            ability_vp9: 0,
            ability_h264: 0,
            ability_h265: 0,
            prefer: ::protobuf::EnumOrUnknown::from_i32(0),
            ability_vp8: 0,
            ability_av1: 0,
            i444: ::protobuf::MessageField::none(),
            prefer_chroma: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SupportedDecoding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SupportedDecoding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SupportedDecoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedDecoding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SupportedDecoding`
pub mod supported_decoding {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.SupportedDecoding.PreferCodec)
    pub enum PreferCodec {
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.Auto)
        Auto = 0,
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.VP9)
        VP9 = 1,
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.H264)
        H264 = 2,
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.H265)
        H265 = 3,
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.VP8)
        VP8 = 4,
        // @@protoc_insertion_point(enum_value:hbb.SupportedDecoding.PreferCodec.AV1)
        AV1 = 5,
    }

    impl ::protobuf::Enum for PreferCodec {
        const NAME: &'static str = "PreferCodec";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PreferCodec> {
            match value {
                0 => ::std::option::Option::Some(PreferCodec::Auto),
                1 => ::std::option::Option::Some(PreferCodec::VP9),
                2 => ::std::option::Option::Some(PreferCodec::H264),
                3 => ::std::option::Option::Some(PreferCodec::H265),
                4 => ::std::option::Option::Some(PreferCodec::VP8),
                5 => ::std::option::Option::Some(PreferCodec::AV1),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PreferCodec> {
            match str {
                "Auto" => ::std::option::Option::Some(PreferCodec::Auto),
                "VP9" => ::std::option::Option::Some(PreferCodec::VP9),
                "H264" => ::std::option::Option::Some(PreferCodec::H264),
                "H265" => ::std::option::Option::Some(PreferCodec::H265),
                "VP8" => ::std::option::Option::Some(PreferCodec::VP8),
                "AV1" => ::std::option::Option::Some(PreferCodec::AV1),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PreferCodec] = &[
            PreferCodec::Auto,
            PreferCodec::VP9,
            PreferCodec::H264,
            PreferCodec::H265,
            PreferCodec::VP8,
            PreferCodec::AV1,
        ];
    }

    impl ::protobuf::EnumFull for PreferCodec {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SupportedDecoding.PreferCodec").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PreferCodec {
        fn default() -> Self {
            PreferCodec::Auto
        }
    }

    impl PreferCodec {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PreferCodec>("SupportedDecoding.PreferCodec")
        }
    }
}

// @@protoc_insertion_point(message:hbb.OptionMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OptionMessage {
    // message fields
    // @@protoc_insertion_point(field:hbb.OptionMessage.image_quality)
    pub image_quality: ::protobuf::EnumOrUnknown<ImageQuality>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.lock_after_session_end)
    pub lock_after_session_end: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.show_remote_cursor)
    pub show_remote_cursor: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.privacy_mode)
    pub privacy_mode: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.block_input)
    pub block_input: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.custom_image_quality)
    pub custom_image_quality: i32,
    // @@protoc_insertion_point(field:hbb.OptionMessage.disable_audio)
    pub disable_audio: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.disable_clipboard)
    pub disable_clipboard: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.enable_file_transfer)
    pub enable_file_transfer: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.supported_decoding)
    pub supported_decoding: ::protobuf::MessageField<SupportedDecoding>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.custom_fps)
    pub custom_fps: i32,
    // @@protoc_insertion_point(field:hbb.OptionMessage.disable_keyboard)
    pub disable_keyboard: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.follow_remote_cursor)
    pub follow_remote_cursor: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.follow_remote_window)
    pub follow_remote_window: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.OptionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OptionMessage {
    fn default() -> &'a OptionMessage {
        <OptionMessage as ::protobuf::Message>::default_instance()
    }
}

impl OptionMessage {
    pub fn new() -> OptionMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_quality",
            |m: &OptionMessage| { &m.image_quality },
            |m: &mut OptionMessage| { &mut m.image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lock_after_session_end",
            |m: &OptionMessage| { &m.lock_after_session_end },
            |m: &mut OptionMessage| { &mut m.lock_after_session_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_remote_cursor",
            |m: &OptionMessage| { &m.show_remote_cursor },
            |m: &mut OptionMessage| { &mut m.show_remote_cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privacy_mode",
            |m: &OptionMessage| { &m.privacy_mode },
            |m: &mut OptionMessage| { &mut m.privacy_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_input",
            |m: &OptionMessage| { &m.block_input },
            |m: &mut OptionMessage| { &mut m.block_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_image_quality",
            |m: &OptionMessage| { &m.custom_image_quality },
            |m: &mut OptionMessage| { &mut m.custom_image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_audio",
            |m: &OptionMessage| { &m.disable_audio },
            |m: &mut OptionMessage| { &mut m.disable_audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_clipboard",
            |m: &OptionMessage| { &m.disable_clipboard },
            |m: &mut OptionMessage| { &mut m.disable_clipboard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable_file_transfer",
            |m: &OptionMessage| { &m.enable_file_transfer },
            |m: &mut OptionMessage| { &mut m.enable_file_transfer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SupportedDecoding>(
            "supported_decoding",
            |m: &OptionMessage| { &m.supported_decoding },
            |m: &mut OptionMessage| { &mut m.supported_decoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fps",
            |m: &OptionMessage| { &m.custom_fps },
            |m: &mut OptionMessage| { &mut m.custom_fps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_keyboard",
            |m: &OptionMessage| { &m.disable_keyboard },
            |m: &mut OptionMessage| { &mut m.disable_keyboard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "follow_remote_cursor",
            |m: &OptionMessage| { &m.follow_remote_cursor },
            |m: &mut OptionMessage| { &mut m.follow_remote_cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "follow_remote_window",
            |m: &OptionMessage| { &m.follow_remote_window },
            |m: &mut OptionMessage| { &mut m.follow_remote_window },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptionMessage>(
            "OptionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OptionMessage {
    const NAME: &'static str = "OptionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.image_quality = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.lock_after_session_end = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.show_remote_cursor = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.privacy_mode = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.block_input = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.custom_image_quality = is.read_int32()?;
                },
                56 => {
                    self.disable_audio = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.disable_clipboard = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.enable_file_transfer = is.read_enum_or_unknown()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.supported_decoding)?;
                },
                88 => {
                    self.custom_fps = is.read_int32()?;
                },
                96 => {
                    self.disable_keyboard = is.read_enum_or_unknown()?;
                },
                120 => {
                    self.follow_remote_cursor = is.read_enum_or_unknown()?;
                },
                128 => {
                    self.follow_remote_window = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.image_quality != ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet) {
            my_size += ::protobuf::rt::int32_size(1, self.image_quality.value());
        }
        if self.lock_after_session_end != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(2, self.lock_after_session_end.value());
        }
        if self.show_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(3, self.show_remote_cursor.value());
        }
        if self.privacy_mode != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(4, self.privacy_mode.value());
        }
        if self.block_input != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(5, self.block_input.value());
        }
        if self.custom_image_quality != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.custom_image_quality);
        }
        if self.disable_audio != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(7, self.disable_audio.value());
        }
        if self.disable_clipboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(8, self.disable_clipboard.value());
        }
        if self.enable_file_transfer != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(9, self.enable_file_transfer.value());
        }
        if let Some(v) = self.supported_decoding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.custom_fps != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.custom_fps);
        }
        if self.disable_keyboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(12, self.disable_keyboard.value());
        }
        if self.follow_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(15, self.follow_remote_cursor.value());
        }
        if self.follow_remote_window != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(16, self.follow_remote_window.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.image_quality != ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.image_quality))?;
        }
        if self.lock_after_session_end != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.lock_after_session_end))?;
        }
        if self.show_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.show_remote_cursor))?;
        }
        if self.privacy_mode != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.privacy_mode))?;
        }
        if self.block_input != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.block_input))?;
        }
        if self.custom_image_quality != 0 {
            os.write_int32(6, self.custom_image_quality)?;
        }
        if self.disable_audio != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.disable_audio))?;
        }
        if self.disable_clipboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.disable_clipboard))?;
        }
        if self.enable_file_transfer != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.enable_file_transfer))?;
        }
        if let Some(v) = self.supported_decoding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.custom_fps != 0 {
            os.write_int32(11, self.custom_fps)?;
        }
        if self.disable_keyboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.disable_keyboard))?;
        }
        if self.follow_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.follow_remote_cursor))?;
        }
        if self.follow_remote_window != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&self.follow_remote_window))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OptionMessage {
        OptionMessage::new()
    }

    fn clear(&mut self) {
        self.image_quality = ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet);
        self.lock_after_session_end = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.show_remote_cursor = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.privacy_mode = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.block_input = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.custom_image_quality = 0;
        self.disable_audio = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.disable_clipboard = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.enable_file_transfer = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.supported_decoding.clear();
        self.custom_fps = 0;
        self.disable_keyboard = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.follow_remote_cursor = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.follow_remote_window = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OptionMessage {
        static instance: OptionMessage = OptionMessage {
            image_quality: ::protobuf::EnumOrUnknown::from_i32(0),
            lock_after_session_end: ::protobuf::EnumOrUnknown::from_i32(0),
            show_remote_cursor: ::protobuf::EnumOrUnknown::from_i32(0),
            privacy_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            block_input: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_image_quality: 0,
            disable_audio: ::protobuf::EnumOrUnknown::from_i32(0),
            disable_clipboard: ::protobuf::EnumOrUnknown::from_i32(0),
            enable_file_transfer: ::protobuf::EnumOrUnknown::from_i32(0),
            supported_decoding: ::protobuf::MessageField::none(),
            custom_fps: 0,
            disable_keyboard: ::protobuf::EnumOrUnknown::from_i32(0),
            follow_remote_cursor: ::protobuf::EnumOrUnknown::from_i32(0),
            follow_remote_window: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OptionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OptionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OptionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OptionMessage`
pub mod option_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.OptionMessage.BoolOption)
    pub enum BoolOption {
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.NotSet)
        NotSet = 0,
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.No)
        No = 1,
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.Yes)
        Yes = 2,
    }

    impl ::protobuf::Enum for BoolOption {
        const NAME: &'static str = "BoolOption";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BoolOption> {
            match value {
                0 => ::std::option::Option::Some(BoolOption::NotSet),
                1 => ::std::option::Option::Some(BoolOption::No),
                2 => ::std::option::Option::Some(BoolOption::Yes),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BoolOption> {
            match str {
                "NotSet" => ::std::option::Option::Some(BoolOption::NotSet),
                "No" => ::std::option::Option::Some(BoolOption::No),
                "Yes" => ::std::option::Option::Some(BoolOption::Yes),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BoolOption] = &[
            BoolOption::NotSet,
            BoolOption::No,
            BoolOption::Yes,
        ];
    }

    impl ::protobuf::EnumFull for BoolOption {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OptionMessage.BoolOption").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BoolOption {
        fn default() -> Self {
            BoolOption::NotSet
        }
    }

    impl BoolOption {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BoolOption>("OptionMessage.BoolOption")
        }
    }
}

// @@protoc_insertion_point(message:hbb.TestDelay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestDelay {
    // message fields
    // @@protoc_insertion_point(field:hbb.TestDelay.time)
    pub time: i64,
    // @@protoc_insertion_point(field:hbb.TestDelay.from_client)
    pub from_client: bool,
    // @@protoc_insertion_point(field:hbb.TestDelay.last_delay)
    pub last_delay: u32,
    // @@protoc_insertion_point(field:hbb.TestDelay.target_bitrate)
    pub target_bitrate: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TestDelay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestDelay {
    fn default() -> &'a TestDelay {
        <TestDelay as ::protobuf::Message>::default_instance()
    }
}

impl TestDelay {
    pub fn new() -> TestDelay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &TestDelay| { &m.time },
            |m: &mut TestDelay| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_client",
            |m: &TestDelay| { &m.from_client },
            |m: &mut TestDelay| { &mut m.from_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_delay",
            |m: &TestDelay| { &m.last_delay },
            |m: &mut TestDelay| { &mut m.last_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_bitrate",
            |m: &TestDelay| { &m.target_bitrate },
            |m: &mut TestDelay| { &mut m.target_bitrate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestDelay>(
            "TestDelay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestDelay {
    const NAME: &'static str = "TestDelay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = is.read_int64()?;
                },
                16 => {
                    self.from_client = is.read_bool()?;
                },
                24 => {
                    self.last_delay = is.read_uint32()?;
                },
                32 => {
                    self.target_bitrate = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.time);
        }
        if self.from_client != false {
            my_size += 1 + 1;
        }
        if self.last_delay != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.last_delay);
        }
        if self.target_bitrate != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.target_bitrate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.time != 0 {
            os.write_int64(1, self.time)?;
        }
        if self.from_client != false {
            os.write_bool(2, self.from_client)?;
        }
        if self.last_delay != 0 {
            os.write_uint32(3, self.last_delay)?;
        }
        if self.target_bitrate != 0 {
            os.write_uint32(4, self.target_bitrate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestDelay {
        TestDelay::new()
    }

    fn clear(&mut self) {
        self.time = 0;
        self.from_client = false;
        self.last_delay = 0;
        self.target_bitrate = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestDelay {
        static instance: TestDelay = TestDelay {
            time: 0,
            from_client: false,
            last_delay: 0,
            target_bitrate: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestDelay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestDelay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestDelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDelay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PublicKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKey {
    // message fields
    // @@protoc_insertion_point(field:hbb.PublicKey.asymmetric_value)
    pub asymmetric_value: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.PublicKey.symmetric_value)
    pub symmetric_value: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKey {
    fn default() -> &'a PublicKey {
        <PublicKey as ::protobuf::Message>::default_instance()
    }
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asymmetric_value",
            |m: &PublicKey| { &m.asymmetric_value },
            |m: &mut PublicKey| { &mut m.asymmetric_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symmetric_value",
            |m: &PublicKey| { &m.symmetric_value },
            |m: &mut PublicKey| { &mut m.symmetric_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicKey>(
            "PublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublicKey {
    const NAME: &'static str = "PublicKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.asymmetric_value = is.read_tokio_bytes()?;
                },
                18 => {
                    self.symmetric_value = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.asymmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asymmetric_value);
        }
        if !self.symmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.symmetric_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.asymmetric_value.is_empty() {
            os.write_bytes(1, &self.asymmetric_value)?;
        }
        if !self.symmetric_value.is_empty() {
            os.write_bytes(2, &self.symmetric_value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn clear(&mut self) {
        self.asymmetric_value.clear();
        self.symmetric_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKey {
        static instance: PublicKey = PublicKey {
            asymmetric_value: ::bytes::Bytes::new(),
            symmetric_value: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SignedId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SignedId {
    // message fields
    // @@protoc_insertion_point(field:hbb.SignedId.id)
    pub id: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SignedId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedId {
    fn default() -> &'a SignedId {
        <SignedId as ::protobuf::Message>::default_instance()
    }
}

impl SignedId {
    pub fn new() -> SignedId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SignedId| { &m.id },
            |m: &mut SignedId| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedId>(
            "SignedId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedId {
    const NAME: &'static str = "SignedId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedId {
        SignedId::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedId {
        static instance: SignedId = SignedId {
            id: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.AudioFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioFormat {
    // message fields
    // @@protoc_insertion_point(field:hbb.AudioFormat.sample_rate)
    pub sample_rate: u32,
    // @@protoc_insertion_point(field:hbb.AudioFormat.channels)
    pub channels: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.AudioFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFormat {
    fn default() -> &'a AudioFormat {
        <AudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl AudioFormat {
    pub fn new() -> AudioFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &AudioFormat| { &m.sample_rate },
            |m: &mut AudioFormat| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channels",
            |m: &AudioFormat| { &m.channels },
            |m: &mut AudioFormat| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFormat>(
            "AudioFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFormat {
    const NAME: &'static str = "AudioFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sample_rate = is.read_uint32()?;
                },
                16 => {
                    self.channels = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sample_rate);
        }
        if self.channels != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sample_rate != 0 {
            os.write_uint32(1, self.sample_rate)?;
        }
        if self.channels != 0 {
            os.write_uint32(2, self.channels)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFormat {
        AudioFormat::new()
    }

    fn clear(&mut self) {
        self.sample_rate = 0;
        self.channels = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFormat {
        static instance: AudioFormat = AudioFormat {
            sample_rate: 0,
            channels: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.AudioFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.AudioFrame.data)
    pub data: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.AudioFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFrame {
    fn default() -> &'a AudioFrame {
        <AudioFrame as ::protobuf::Message>::default_instance()
    }
}

impl AudioFrame {
    pub fn new() -> AudioFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &AudioFrame| { &m.data },
            |m: &mut AudioFrame| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFrame>(
            "AudioFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFrame {
    const NAME: &'static str = "AudioFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFrame {
        AudioFrame::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFrame {
        static instance: AudioFrame = AudioFrame {
            data: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.MessageBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageBox {
    // message fields
    // @@protoc_insertion_point(field:hbb.MessageBox.msgtype)
    pub msgtype: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.link)
    pub link: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.MessageBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageBox {
    fn default() -> &'a MessageBox {
        <MessageBox as ::protobuf::Message>::default_instance()
    }
}

impl MessageBox {
    pub fn new() -> MessageBox {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgtype",
            |m: &MessageBox| { &m.msgtype },
            |m: &mut MessageBox| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &MessageBox| { &m.title },
            |m: &mut MessageBox| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &MessageBox| { &m.text },
            |m: &mut MessageBox| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "link",
            |m: &MessageBox| { &m.link },
            |m: &mut MessageBox| { &mut m.link },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageBox>(
            "MessageBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageBox {
    const NAME: &'static str = "MessageBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.msgtype = is.read_string()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                26 => {
                    self.text = is.read_string()?;
                },
                34 => {
                    self.link = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.msgtype.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.msgtype);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.text);
        }
        if !self.link.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.link);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.msgtype.is_empty() {
            os.write_string(1, &self.msgtype)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(3, &self.text)?;
        }
        if !self.link.is_empty() {
            os.write_string(4, &self.link)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageBox {
        MessageBox::new()
    }

    fn clear(&mut self) {
        self.msgtype.clear();
        self.title.clear();
        self.text.clear();
        self.link.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageBox {
        static instance: MessageBox = MessageBox {
            msgtype: ::std::string::String::new(),
            title: ::std::string::String::new(),
            text: ::std::string::String::new(),
            link: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.BackNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BackNotification {
    // message fields
    // @@protoc_insertion_point(field:hbb.BackNotification.details)
    pub details: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.BackNotification.impl_key)
    pub impl_key: ::std::string::String,
    // message oneof groups
    pub union: ::std::option::Option<back_notification::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.BackNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BackNotification {
    fn default() -> &'a BackNotification {
        <BackNotification as ::protobuf::Message>::default_instance()
    }
}

impl BackNotification {
    pub fn new() -> BackNotification {
        ::std::default::Default::default()
    }

    // .hbb.BackNotification.PrivacyModeState privacy_mode_state = 1;

    pub fn privacy_mode_state(&self) -> back_notification::PrivacyModeState {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::PrivacyModeState(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => back_notification::PrivacyModeState::PrvStateUnknown,
        }
    }

    pub fn clear_privacy_mode_state(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_privacy_mode_state(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::PrivacyModeState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_privacy_mode_state(&mut self, v: back_notification::PrivacyModeState) {
        self.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(::protobuf::EnumOrUnknown::new(v)))
    }

    // .hbb.BackNotification.BlockInputState block_input_state = 2;

    pub fn block_input_state(&self) -> back_notification::BlockInputState {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::BlockInputState(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => back_notification::BlockInputState::BlkStateUnknown,
        }
    }

    pub fn clear_block_input_state(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_block_input_state(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::BlockInputState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_input_state(&mut self, v: back_notification::BlockInputState) {
        self.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(::protobuf::EnumOrUnknown::new(v)))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "privacy_mode_state",
            |message: &BackNotification| match &message.union {
                ::std::option::Option::Some(back_notification::Union::PrivacyModeState(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut BackNotification, e: ::protobuf::EnumOrUnknown<back_notification::PrivacyModeState>| {
                message.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(e));
            },
            back_notification::PrivacyModeState::PrvStateUnknown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "block_input_state",
            |message: &BackNotification| match &message.union {
                ::std::option::Option::Some(back_notification::Union::BlockInputState(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut BackNotification, e: ::protobuf::EnumOrUnknown<back_notification::BlockInputState>| {
                message.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(e));
            },
            back_notification::BlockInputState::BlkStateUnknown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "details",
            |m: &BackNotification| { &m.details },
            |m: &mut BackNotification| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "impl_key",
            |m: &BackNotification| { &m.impl_key },
            |m: &mut BackNotification| { &mut m.impl_key },
        ));
        oneofs.push(back_notification::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackNotification>(
            "BackNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BackNotification {
    const NAME: &'static str = "BackNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(is.read_enum_or_unknown()?));
                },
                16 => {
                    self.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(is.read_enum_or_unknown()?));
                },
                26 => {
                    self.details = is.read_string()?;
                },
                34 => {
                    self.impl_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.details);
        }
        if !self.impl_key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.impl_key);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &back_notification::Union::PrivacyModeState(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
                &back_notification::Union::BlockInputState(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.details.is_empty() {
            os.write_string(3, &self.details)?;
        }
        if !self.impl_key.is_empty() {
            os.write_string(4, &self.impl_key)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &back_notification::Union::PrivacyModeState(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &back_notification::Union::BlockInputState(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BackNotification {
        BackNotification::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.details.clear();
        self.impl_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BackNotification {
        static instance: BackNotification = BackNotification {
            details: ::std::string::String::new(),
            impl_key: ::std::string::String::new(),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BackNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BackNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BackNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BackNotification`
pub mod back_notification {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.BackNotification.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.BackNotification.privacy_mode_state)
        PrivacyModeState(::protobuf::EnumOrUnknown<PrivacyModeState>),
        // @@protoc_insertion_point(oneof_field:hbb.BackNotification.block_input_state)
        BlockInputState(::protobuf::EnumOrUnknown<BlockInputState>),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BackNotification as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.BackNotification.BlockInputState)
    pub enum BlockInputState {
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkStateUnknown)
        BlkStateUnknown = 0,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOnSucceeded)
        BlkOnSucceeded = 2,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOnFailed)
        BlkOnFailed = 3,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOffSucceeded)
        BlkOffSucceeded = 4,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOffFailed)
        BlkOffFailed = 5,
    }

    impl ::protobuf::Enum for BlockInputState {
        const NAME: &'static str = "BlockInputState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BlockInputState> {
            match value {
                0 => ::std::option::Option::Some(BlockInputState::BlkStateUnknown),
                2 => ::std::option::Option::Some(BlockInputState::BlkOnSucceeded),
                3 => ::std::option::Option::Some(BlockInputState::BlkOnFailed),
                4 => ::std::option::Option::Some(BlockInputState::BlkOffSucceeded),
                5 => ::std::option::Option::Some(BlockInputState::BlkOffFailed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BlockInputState> {
            match str {
                "BlkStateUnknown" => ::std::option::Option::Some(BlockInputState::BlkStateUnknown),
                "BlkOnSucceeded" => ::std::option::Option::Some(BlockInputState::BlkOnSucceeded),
                "BlkOnFailed" => ::std::option::Option::Some(BlockInputState::BlkOnFailed),
                "BlkOffSucceeded" => ::std::option::Option::Some(BlockInputState::BlkOffSucceeded),
                "BlkOffFailed" => ::std::option::Option::Some(BlockInputState::BlkOffFailed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BlockInputState] = &[
            BlockInputState::BlkStateUnknown,
            BlockInputState::BlkOnSucceeded,
            BlockInputState::BlkOnFailed,
            BlockInputState::BlkOffSucceeded,
            BlockInputState::BlkOffFailed,
        ];
    }

    impl ::protobuf::EnumFull for BlockInputState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BackNotification.BlockInputState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                BlockInputState::BlkStateUnknown => 0,
                BlockInputState::BlkOnSucceeded => 1,
                BlockInputState::BlkOnFailed => 2,
                BlockInputState::BlkOffSucceeded => 3,
                BlockInputState::BlkOffFailed => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BlockInputState {
        fn default() -> Self {
            BlockInputState::BlkStateUnknown
        }
    }

    impl BlockInputState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BlockInputState>("BackNotification.BlockInputState")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.BackNotification.PrivacyModeState)
    pub enum PrivacyModeState {
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvStateUnknown)
        PrvStateUnknown = 0,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnByOther)
        PrvOnByOther = 2,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvNotSupported)
        PrvNotSupported = 3,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnSucceeded)
        PrvOnSucceeded = 4,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailedDenied)
        PrvOnFailedDenied = 5,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailedPlugin)
        PrvOnFailedPlugin = 6,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailed)
        PrvOnFailed = 7,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffSucceeded)
        PrvOffSucceeded = 8,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffByPeer)
        PrvOffByPeer = 9,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffFailed)
        PrvOffFailed = 10,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffUnknown)
        PrvOffUnknown = 11,
    }

    impl ::protobuf::Enum for PrivacyModeState {
        const NAME: &'static str = "PrivacyModeState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PrivacyModeState> {
            match value {
                0 => ::std::option::Option::Some(PrivacyModeState::PrvStateUnknown),
                2 => ::std::option::Option::Some(PrivacyModeState::PrvOnByOther),
                3 => ::std::option::Option::Some(PrivacyModeState::PrvNotSupported),
                4 => ::std::option::Option::Some(PrivacyModeState::PrvOnSucceeded),
                5 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedDenied),
                6 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedPlugin),
                7 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailed),
                8 => ::std::option::Option::Some(PrivacyModeState::PrvOffSucceeded),
                9 => ::std::option::Option::Some(PrivacyModeState::PrvOffByPeer),
                10 => ::std::option::Option::Some(PrivacyModeState::PrvOffFailed),
                11 => ::std::option::Option::Some(PrivacyModeState::PrvOffUnknown),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PrivacyModeState> {
            match str {
                "PrvStateUnknown" => ::std::option::Option::Some(PrivacyModeState::PrvStateUnknown),
                "PrvOnByOther" => ::std::option::Option::Some(PrivacyModeState::PrvOnByOther),
                "PrvNotSupported" => ::std::option::Option::Some(PrivacyModeState::PrvNotSupported),
                "PrvOnSucceeded" => ::std::option::Option::Some(PrivacyModeState::PrvOnSucceeded),
                "PrvOnFailedDenied" => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedDenied),
                "PrvOnFailedPlugin" => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedPlugin),
                "PrvOnFailed" => ::std::option::Option::Some(PrivacyModeState::PrvOnFailed),
                "PrvOffSucceeded" => ::std::option::Option::Some(PrivacyModeState::PrvOffSucceeded),
                "PrvOffByPeer" => ::std::option::Option::Some(PrivacyModeState::PrvOffByPeer),
                "PrvOffFailed" => ::std::option::Option::Some(PrivacyModeState::PrvOffFailed),
                "PrvOffUnknown" => ::std::option::Option::Some(PrivacyModeState::PrvOffUnknown),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PrivacyModeState] = &[
            PrivacyModeState::PrvStateUnknown,
            PrivacyModeState::PrvOnByOther,
            PrivacyModeState::PrvNotSupported,
            PrivacyModeState::PrvOnSucceeded,
            PrivacyModeState::PrvOnFailedDenied,
            PrivacyModeState::PrvOnFailedPlugin,
            PrivacyModeState::PrvOnFailed,
            PrivacyModeState::PrvOffSucceeded,
            PrivacyModeState::PrvOffByPeer,
            PrivacyModeState::PrvOffFailed,
            PrivacyModeState::PrvOffUnknown,
        ];
    }

    impl ::protobuf::EnumFull for PrivacyModeState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BackNotification.PrivacyModeState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                PrivacyModeState::PrvStateUnknown => 0,
                PrivacyModeState::PrvOnByOther => 1,
                PrivacyModeState::PrvNotSupported => 2,
                PrivacyModeState::PrvOnSucceeded => 3,
                PrivacyModeState::PrvOnFailedDenied => 4,
                PrivacyModeState::PrvOnFailedPlugin => 5,
                PrivacyModeState::PrvOnFailed => 6,
                PrivacyModeState::PrvOffSucceeded => 7,
                PrivacyModeState::PrvOffByPeer => 8,
                PrivacyModeState::PrvOffFailed => 9,
                PrivacyModeState::PrvOffUnknown => 10,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PrivacyModeState {
        fn default() -> Self {
            PrivacyModeState::PrvStateUnknown
        }
    }

    impl PrivacyModeState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PrivacyModeState>("BackNotification.PrivacyModeState")
        }
    }
}

// @@protoc_insertion_point(message:hbb.ElevationRequestWithLogon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ElevationRequestWithLogon {
    // message fields
    // @@protoc_insertion_point(field:hbb.ElevationRequestWithLogon.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ElevationRequestWithLogon.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ElevationRequestWithLogon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ElevationRequestWithLogon {
    fn default() -> &'a ElevationRequestWithLogon {
        <ElevationRequestWithLogon as ::protobuf::Message>::default_instance()
    }
}

impl ElevationRequestWithLogon {
    pub fn new() -> ElevationRequestWithLogon {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &ElevationRequestWithLogon| { &m.username },
            |m: &mut ElevationRequestWithLogon| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &ElevationRequestWithLogon| { &m.password },
            |m: &mut ElevationRequestWithLogon| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ElevationRequestWithLogon>(
            "ElevationRequestWithLogon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ElevationRequestWithLogon {
    const NAME: &'static str = "ElevationRequestWithLogon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ElevationRequestWithLogon {
        ElevationRequestWithLogon::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ElevationRequestWithLogon {
        static instance: ElevationRequestWithLogon = ElevationRequestWithLogon {
            username: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ElevationRequestWithLogon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ElevationRequestWithLogon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ElevationRequestWithLogon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ElevationRequestWithLogon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.ElevationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ElevationRequest {
    // message oneof groups
    pub union: ::std::option::Option<elevation_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ElevationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ElevationRequest {
    fn default() -> &'a ElevationRequest {
        <ElevationRequest as ::protobuf::Message>::default_instance()
    }
}

impl ElevationRequest {
    pub fn new() -> ElevationRequest {
        ::std::default::Default::default()
    }

    // bool direct = 1;

    pub fn direct(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Direct(v)) => v,
            _ => false,
        }
    }

    pub fn clear_direct(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_direct(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Direct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(elevation_request::Union::Direct(v))
    }

    // .hbb.ElevationRequestWithLogon logon = 2;

    pub fn logon(&self) -> &ElevationRequestWithLogon {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(ref v)) => v,
            _ => <ElevationRequestWithLogon as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_logon(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_logon(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logon(&mut self, v: ElevationRequestWithLogon) {
        self.union = ::std::option::Option::Some(elevation_request::Union::Logon(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logon(&mut self) -> &mut ElevationRequestWithLogon {
        if let ::std::option::Option::Some(elevation_request::Union::Logon(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(elevation_request::Union::Logon(ElevationRequestWithLogon::new()));
        }
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logon(&mut self) -> ElevationRequestWithLogon {
        if self.has_logon() {
            match self.union.take() {
                ::std::option::Option::Some(elevation_request::Union::Logon(v)) => v,
                _ => panic!(),
            }
        } else {
            ElevationRequestWithLogon::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "direct",
            ElevationRequest::has_direct,
            ElevationRequest::direct,
            ElevationRequest::set_direct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ElevationRequestWithLogon>(
            "logon",
            ElevationRequest::has_logon,
            ElevationRequest::logon,
            ElevationRequest::mut_logon,
            ElevationRequest::set_logon,
        ));
        oneofs.push(elevation_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ElevationRequest>(
            "ElevationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ElevationRequest {
    const NAME: &'static str = "ElevationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.union = ::std::option::Option::Some(elevation_request::Union::Direct(is.read_bool()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(elevation_request::Union::Logon(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &elevation_request::Union::Direct(v) => {
                    my_size += 1 + 1;
                },
                &elevation_request::Union::Logon(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &elevation_request::Union::Direct(v) => {
                    os.write_bool(1, v)?;
                },
                &elevation_request::Union::Logon(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ElevationRequest {
        ElevationRequest::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ElevationRequest {
        static instance: ElevationRequest = ElevationRequest {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ElevationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ElevationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ElevationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ElevationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ElevationRequest`
pub mod elevation_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.ElevationRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.ElevationRequest.direct)
        Direct(bool),
        // @@protoc_insertion_point(oneof_field:hbb.ElevationRequest.logon)
        Logon(super::ElevationRequestWithLogon),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ElevationRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.SwitchSidesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchSidesRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.SwitchSidesRequest.uuid)
    pub uuid: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SwitchSidesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchSidesRequest {
    fn default() -> &'a SwitchSidesRequest {
        <SwitchSidesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchSidesRequest {
    pub fn new() -> SwitchSidesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &SwitchSidesRequest| { &m.uuid },
            |m: &mut SwitchSidesRequest| { &mut m.uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchSidesRequest>(
            "SwitchSidesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchSidesRequest {
    const NAME: &'static str = "SwitchSidesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_bytes(1, &self.uuid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchSidesRequest {
        SwitchSidesRequest::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchSidesRequest {
        static instance: SwitchSidesRequest = SwitchSidesRequest {
            uuid: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchSidesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchSidesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchSidesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchSidesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SwitchSidesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchSidesResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.SwitchSidesResponse.uuid)
    pub uuid: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.SwitchSidesResponse.lr)
    pub lr: ::protobuf::MessageField<LoginRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SwitchSidesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchSidesResponse {
    fn default() -> &'a SwitchSidesResponse {
        <SwitchSidesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchSidesResponse {
    pub fn new() -> SwitchSidesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &SwitchSidesResponse| { &m.uuid },
            |m: &mut SwitchSidesResponse| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginRequest>(
            "lr",
            |m: &SwitchSidesResponse| { &m.lr },
            |m: &mut SwitchSidesResponse| { &mut m.lr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchSidesResponse>(
            "SwitchSidesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchSidesResponse {
    const NAME: &'static str = "SwitchSidesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_tokio_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.uuid);
        }
        if let Some(v) = self.lr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_bytes(1, &self.uuid)?;
        }
        if let Some(v) = self.lr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchSidesResponse {
        SwitchSidesResponse::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.lr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchSidesResponse {
        static instance: SwitchSidesResponse = SwitchSidesResponse {
            uuid: ::bytes::Bytes::new(),
            lr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchSidesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchSidesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchSidesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchSidesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.SwitchBack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchBack {
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SwitchBack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchBack {
    fn default() -> &'a SwitchBack {
        <SwitchBack as ::protobuf::Message>::default_instance()
    }
}

impl SwitchBack {
    pub fn new() -> SwitchBack {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchBack>(
            "SwitchBack",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchBack {
    const NAME: &'static str = "SwitchBack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchBack {
        SwitchBack::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchBack {
        static instance: SwitchBack = SwitchBack {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchBack {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchBack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchBack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchBack {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PluginRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PluginRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.PluginRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PluginRequest.content)
    pub content: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PluginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginRequest {
    fn default() -> &'a PluginRequest {
        <PluginRequest as ::protobuf::Message>::default_instance()
    }
}

impl PluginRequest {
    pub fn new() -> PluginRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PluginRequest| { &m.id },
            |m: &mut PluginRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &PluginRequest| { &m.content },
            |m: &mut PluginRequest| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginRequest>(
            "PluginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginRequest {
    const NAME: &'static str = "PluginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.content = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginRequest {
        PluginRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginRequest {
        static instance: PluginRequest = PluginRequest {
            id: ::std::string::String::new(),
            content: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.PluginFailure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PluginFailure {
    // message fields
    // @@protoc_insertion_point(field:hbb.PluginFailure.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PluginFailure.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PluginFailure.msg)
    pub msg: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PluginFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginFailure {
    fn default() -> &'a PluginFailure {
        <PluginFailure as ::protobuf::Message>::default_instance()
    }
}

impl PluginFailure {
    pub fn new() -> PluginFailure {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PluginFailure| { &m.id },
            |m: &mut PluginFailure| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &PluginFailure| { &m.name },
            |m: &mut PluginFailure| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &PluginFailure| { &m.msg },
            |m: &mut PluginFailure| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginFailure>(
            "PluginFailure",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginFailure {
    const NAME: &'static str = "PluginFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.msg = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.msg.is_empty() {
            os.write_string(3, &self.msg)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginFailure {
        PluginFailure::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginFailure {
        static instance: PluginFailure = PluginFailure {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            msg: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginFailure {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginFailure {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.WindowsSessions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WindowsSessions {
    // message fields
    // @@protoc_insertion_point(field:hbb.WindowsSessions.sessions)
    pub sessions: ::std::vec::Vec<WindowsSession>,
    // @@protoc_insertion_point(field:hbb.WindowsSessions.current_sid)
    pub current_sid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.WindowsSessions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowsSessions {
    fn default() -> &'a WindowsSessions {
        <WindowsSessions as ::protobuf::Message>::default_instance()
    }
}

impl WindowsSessions {
    pub fn new() -> WindowsSessions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sessions",
            |m: &WindowsSessions| { &m.sessions },
            |m: &mut WindowsSessions| { &mut m.sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_sid",
            |m: &WindowsSessions| { &m.current_sid },
            |m: &mut WindowsSessions| { &mut m.current_sid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowsSessions>(
            "WindowsSessions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowsSessions {
    const NAME: &'static str = "WindowsSessions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sessions.push(is.read_message()?);
                },
                16 => {
                    self.current_sid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.current_sid != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.current_sid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sessions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.current_sid != 0 {
            os.write_uint32(2, self.current_sid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowsSessions {
        WindowsSessions::new()
    }

    fn clear(&mut self) {
        self.sessions.clear();
        self.current_sid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowsSessions {
        static instance: WindowsSessions = WindowsSessions {
            sessions: ::std::vec::Vec::new(),
            current_sid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowsSessions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowsSessions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowsSessions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsSessions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.MessageQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageQuery {
    // message fields
    // @@protoc_insertion_point(field:hbb.MessageQuery.switch_display)
    pub switch_display: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.MessageQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageQuery {
    fn default() -> &'a MessageQuery {
        <MessageQuery as ::protobuf::Message>::default_instance()
    }
}

impl MessageQuery {
    pub fn new() -> MessageQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "switch_display",
            |m: &MessageQuery| { &m.switch_display },
            |m: &mut MessageQuery| { &mut m.switch_display },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageQuery>(
            "MessageQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageQuery {
    const NAME: &'static str = "MessageQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.switch_display = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.switch_display != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.switch_display);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.switch_display != 0 {
            os.write_int32(1, self.switch_display)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageQuery {
        MessageQuery::new()
    }

    fn clear(&mut self) {
        self.switch_display = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageQuery {
        static instance: MessageQuery = MessageQuery {
            switch_display: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Misc)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Misc {
    // message oneof groups
    pub union: ::std::option::Option<misc::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Misc.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Misc {
    fn default() -> &'a Misc {
        <Misc as ::protobuf::Message>::default_instance()
    }
}

impl Misc {
    pub fn new() -> Misc {
        ::std::default::Default::default()
    }

    // .hbb.ChatMessage chat_message = 4;

    pub fn chat_message(&self) -> &ChatMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(ref v)) => v,
            _ => <ChatMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chat_message(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chat_message(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ChatMessage) {
        self.union = ::std::option::Option::Some(misc::Union::ChatMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ChatMessage {
        if let ::std::option::Option::Some(misc::Union::ChatMessage(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ChatMessage(ChatMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ChatMessage {
        if self.has_chat_message() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ChatMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ChatMessage::new()
        }
    }

    // .hbb.SwitchDisplay switch_display = 5;

    pub fn switch_display(&self) -> &SwitchDisplay {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(ref v)) => v,
            _ => <SwitchDisplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_display(&mut self, v: SwitchDisplay) {
        self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_display(&mut self) -> &mut SwitchDisplay {
        if let ::std::option::Option::Some(misc::Union::SwitchDisplay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(SwitchDisplay::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_display(&mut self) -> SwitchDisplay {
        if self.has_switch_display() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::SwitchDisplay(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchDisplay::new()
        }
    }

    // .hbb.PermissionInfo permission_info = 6;

    pub fn permission_info(&self) -> &PermissionInfo {
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(ref v)) => v,
            _ => <PermissionInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_permission_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_permission_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_permission_info(&mut self, v: PermissionInfo) {
        self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_permission_info(&mut self) -> &mut PermissionInfo {
        if let ::std::option::Option::Some(misc::Union::PermissionInfo(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(PermissionInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_permission_info(&mut self) -> PermissionInfo {
        if self.has_permission_info() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::PermissionInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PermissionInfo::new()
        }
    }

    // .hbb.OptionMessage option = 7;

    pub fn option(&self) -> &OptionMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(ref v)) => v,
            _ => <OptionMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_option(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: OptionMessage) {
        self.union = ::std::option::Option::Some(misc::Union::Option(v))
    }

    // Mutable pointer to the field.
    pub fn mut_option(&mut self) -> &mut OptionMessage {
        if let ::std::option::Option::Some(misc::Union::Option(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::Option(OptionMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_option(&mut self) -> OptionMessage {
        if self.has_option() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::Option(v)) => v,
                _ => panic!(),
            }
        } else {
            OptionMessage::new()
        }
    }

    // .hbb.AudioFormat audio_format = 8;

    pub fn audio_format(&self) -> &AudioFormat {
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(ref v)) => v,
            _ => <AudioFormat as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_format(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_format(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_format(&mut self, v: AudioFormat) {
        self.union = ::std::option::Option::Some(misc::Union::AudioFormat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_format(&mut self) -> &mut AudioFormat {
        if let ::std::option::Option::Some(misc::Union::AudioFormat(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::AudioFormat(AudioFormat::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_format(&mut self) -> AudioFormat {
        if self.has_audio_format() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::AudioFormat(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFormat::new()
        }
    }

    // string close_reason = 9;

    pub fn close_reason(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_close_reason(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(misc::Union::CloseReason(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_reason(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(misc::Union::CloseReason(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::CloseReason(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_reason(&mut self) -> ::std::string::String {
        if self.has_close_reason() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::CloseReason(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool refresh_video = 10;

    pub fn refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideo(v)) => v,
            _ => false,
        }
    }

    pub fn clear_refresh_video(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refresh_video(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::RefreshVideo(v))
    }

    // bool video_received = 12;

    pub fn video_received(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::VideoReceived(v)) => v,
            _ => false,
        }
    }

    pub fn clear_video_received(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_video_received(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::VideoReceived(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video_received(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::VideoReceived(v))
    }

    // .hbb.BackNotification back_notification = 13;

    pub fn back_notification(&self) -> &BackNotification {
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(ref v)) => v,
            _ => <BackNotification as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_back_notification(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_back_notification(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_back_notification(&mut self, v: BackNotification) {
        self.union = ::std::option::Option::Some(misc::Union::BackNotification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_back_notification(&mut self) -> &mut BackNotification {
        if let ::std::option::Option::Some(misc::Union::BackNotification(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::BackNotification(BackNotification::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_back_notification(&mut self) -> BackNotification {
        if self.has_back_notification() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::BackNotification(v)) => v,
                _ => panic!(),
            }
        } else {
            BackNotification::new()
        }
    }

    // bool restart_remote_device = 14;

    pub fn restart_remote_device(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RestartRemoteDevice(v)) => v,
            _ => false,
        }
    }

    pub fn clear_restart_remote_device(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_restart_remote_device(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RestartRemoteDevice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_remote_device(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::RestartRemoteDevice(v))
    }

    // bool uac = 15;

    pub fn uac(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Uac(v)) => v,
            _ => false,
        }
    }

    pub fn clear_uac(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_uac(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Uac(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uac(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::Uac(v))
    }

    // bool foreground_window_elevated = 16;

    pub fn foreground_window_elevated(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(v)) => v,
            _ => false,
        }
    }

    pub fn clear_foreground_window_elevated(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_foreground_window_elevated(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foreground_window_elevated(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(v))
    }

    // bool stop_service = 17;

    pub fn stop_service(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::StopService(v)) => v,
            _ => false,
        }
    }

    pub fn clear_stop_service(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_stop_service(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::StopService(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_service(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::StopService(v))
    }

    // .hbb.ElevationRequest elevation_request = 18;

    pub fn elevation_request(&self) -> &ElevationRequest {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(ref v)) => v,
            _ => <ElevationRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_elevation_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_elevation_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_elevation_request(&mut self, v: ElevationRequest) {
        self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_elevation_request(&mut self) -> &mut ElevationRequest {
        if let ::std::option::Option::Some(misc::Union::ElevationRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(ElevationRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_elevation_request(&mut self) -> ElevationRequest {
        if self.has_elevation_request() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ElevationRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ElevationRequest::new()
        }
    }

    // string elevation_response = 19;

    pub fn elevation_response(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_elevation_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_elevation_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_elevation_response(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_elevation_response(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(misc::Union::ElevationResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_elevation_response(&mut self) -> ::std::string::String {
        if self.has_elevation_response() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ElevationResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool portable_service_running = 20;

    pub fn portable_service_running(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PortableServiceRunning(v)) => v,
            _ => false,
        }
    }

    pub fn clear_portable_service_running(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_portable_service_running(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PortableServiceRunning(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_portable_service_running(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::PortableServiceRunning(v))
    }

    // .hbb.SwitchSidesRequest switch_sides_request = 21;

    pub fn switch_sides_request(&self) -> &SwitchSidesRequest {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchSidesRequest(ref v)) => v,
            _ => <SwitchSidesRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_sides_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_sides_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchSidesRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_sides_request(&mut self, v: SwitchSidesRequest) {
        self.union = ::std::option::Option::Some(misc::Union::SwitchSidesRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_sides_request(&mut self) -> &mut SwitchSidesRequest {
        if let ::std::option::Option::Some(misc::Union::SwitchSidesRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::SwitchSidesRequest(SwitchSidesRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchSidesRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_sides_request(&mut self) -> SwitchSidesRequest {
        if self.has_switch_sides_request() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::SwitchSidesRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchSidesRequest::new()
        }
    }

    // .hbb.SwitchBack switch_back = 22;

    pub fn switch_back(&self) -> &SwitchBack {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchBack(ref v)) => v,
            _ => <SwitchBack as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_back(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_back(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchBack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_back(&mut self, v: SwitchBack) {
        self.union = ::std::option::Option::Some(misc::Union::SwitchBack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_back(&mut self) -> &mut SwitchBack {
        if let ::std::option::Option::Some(misc::Union::SwitchBack(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::SwitchBack(SwitchBack::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchBack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_back(&mut self) -> SwitchBack {
        if self.has_switch_back() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::SwitchBack(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchBack::new()
        }
    }

    // .hbb.Resolution change_resolution = 24;

    pub fn change_resolution(&self) -> &Resolution {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeResolution(ref v)) => v,
            _ => <Resolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_change_resolution(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_change_resolution(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeResolution(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_change_resolution(&mut self, v: Resolution) {
        self.union = ::std::option::Option::Some(misc::Union::ChangeResolution(v))
    }

    // Mutable pointer to the field.
    pub fn mut_change_resolution(&mut self) -> &mut Resolution {
        if let ::std::option::Option::Some(misc::Union::ChangeResolution(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ChangeResolution(Resolution::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeResolution(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_change_resolution(&mut self) -> Resolution {
        if self.has_change_resolution() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ChangeResolution(v)) => v,
                _ => panic!(),
            }
        } else {
            Resolution::new()
        }
    }

    // .hbb.PluginRequest plugin_request = 25;

    pub fn plugin_request(&self) -> &PluginRequest {
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginRequest(ref v)) => v,
            _ => <PluginRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_plugin_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_plugin_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plugin_request(&mut self, v: PluginRequest) {
        self.union = ::std::option::Option::Some(misc::Union::PluginRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_request(&mut self) -> &mut PluginRequest {
        if let ::std::option::Option::Some(misc::Union::PluginRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::PluginRequest(PluginRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plugin_request(&mut self) -> PluginRequest {
        if self.has_plugin_request() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::PluginRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PluginRequest::new()
        }
    }

    // .hbb.PluginFailure plugin_failure = 26;

    pub fn plugin_failure(&self) -> &PluginFailure {
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginFailure(ref v)) => v,
            _ => <PluginFailure as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_plugin_failure(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_plugin_failure(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginFailure(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plugin_failure(&mut self, v: PluginFailure) {
        self.union = ::std::option::Option::Some(misc::Union::PluginFailure(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_failure(&mut self) -> &mut PluginFailure {
        if let ::std::option::Option::Some(misc::Union::PluginFailure(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::PluginFailure(PluginFailure::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::PluginFailure(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plugin_failure(&mut self) -> PluginFailure {
        if self.has_plugin_failure() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::PluginFailure(v)) => v,
                _ => panic!(),
            }
        } else {
            PluginFailure::new()
        }
    }

    // uint32 full_speed_fps = 27;

    pub fn full_speed_fps(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(misc::Union::FullSpeedFps(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_full_speed_fps(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_full_speed_fps(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::FullSpeedFps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_full_speed_fps(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(misc::Union::FullSpeedFps(v))
    }

    // uint32 auto_adjust_fps = 28;

    pub fn auto_adjust_fps(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(misc::Union::AutoAdjustFps(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_auto_adjust_fps(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_auto_adjust_fps(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::AutoAdjustFps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auto_adjust_fps(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(misc::Union::AutoAdjustFps(v))
    }

    // bool client_record_status = 29;

    pub fn client_record_status(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ClientRecordStatus(v)) => v,
            _ => false,
        }
    }

    pub fn clear_client_record_status(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_client_record_status(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ClientRecordStatus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_client_record_status(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::ClientRecordStatus(v))
    }

    // .hbb.CaptureDisplays capture_displays = 30;

    pub fn capture_displays(&self) -> &CaptureDisplays {
        match self.union {
            ::std::option::Option::Some(misc::Union::CaptureDisplays(ref v)) => v,
            _ => <CaptureDisplays as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_capture_displays(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_capture_displays(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::CaptureDisplays(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_capture_displays(&mut self, v: CaptureDisplays) {
        self.union = ::std::option::Option::Some(misc::Union::CaptureDisplays(v))
    }

    // Mutable pointer to the field.
    pub fn mut_capture_displays(&mut self) -> &mut CaptureDisplays {
        if let ::std::option::Option::Some(misc::Union::CaptureDisplays(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::CaptureDisplays(CaptureDisplays::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::CaptureDisplays(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_capture_displays(&mut self) -> CaptureDisplays {
        if self.has_capture_displays() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::CaptureDisplays(v)) => v,
                _ => panic!(),
            }
        } else {
            CaptureDisplays::new()
        }
    }

    // int32 refresh_video_display = 31;

    pub fn refresh_video_display(&self) -> i32 {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideoDisplay(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_refresh_video_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_refresh_video_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideoDisplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refresh_video_display(&mut self, v: i32) {
        self.union = ::std::option::Option::Some(misc::Union::RefreshVideoDisplay(v))
    }

    // .hbb.ToggleVirtualDisplay toggle_virtual_display = 32;

    pub fn toggle_virtual_display(&self) -> &ToggleVirtualDisplay {
        match self.union {
            ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(ref v)) => v,
            _ => <ToggleVirtualDisplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_toggle_virtual_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_toggle_virtual_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_virtual_display(&mut self, v: ToggleVirtualDisplay) {
        self.union = ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_virtual_display(&mut self) -> &mut ToggleVirtualDisplay {
        if let ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(ToggleVirtualDisplay::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_virtual_display(&mut self) -> ToggleVirtualDisplay {
        if self.has_toggle_virtual_display() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(v)) => v,
                _ => panic!(),
            }
        } else {
            ToggleVirtualDisplay::new()
        }
    }

    // .hbb.TogglePrivacyMode toggle_privacy_mode = 33;

    pub fn toggle_privacy_mode(&self) -> &TogglePrivacyMode {
        match self.union {
            ::std::option::Option::Some(misc::Union::TogglePrivacyMode(ref v)) => v,
            _ => <TogglePrivacyMode as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_toggle_privacy_mode(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_toggle_privacy_mode(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::TogglePrivacyMode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_privacy_mode(&mut self, v: TogglePrivacyMode) {
        self.union = ::std::option::Option::Some(misc::Union::TogglePrivacyMode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_privacy_mode(&mut self) -> &mut TogglePrivacyMode {
        if let ::std::option::Option::Some(misc::Union::TogglePrivacyMode(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::TogglePrivacyMode(TogglePrivacyMode::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::TogglePrivacyMode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_privacy_mode(&mut self) -> TogglePrivacyMode {
        if self.has_toggle_privacy_mode() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::TogglePrivacyMode(v)) => v,
                _ => panic!(),
            }
        } else {
            TogglePrivacyMode::new()
        }
    }

    // .hbb.SupportedEncoding supported_encoding = 34;

    pub fn supported_encoding(&self) -> &SupportedEncoding {
        match self.union {
            ::std::option::Option::Some(misc::Union::SupportedEncoding(ref v)) => v,
            _ => <SupportedEncoding as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_supported_encoding(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_supported_encoding(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SupportedEncoding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_supported_encoding(&mut self, v: SupportedEncoding) {
        self.union = ::std::option::Option::Some(misc::Union::SupportedEncoding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_supported_encoding(&mut self) -> &mut SupportedEncoding {
        if let ::std::option::Option::Some(misc::Union::SupportedEncoding(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::SupportedEncoding(SupportedEncoding::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::SupportedEncoding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_supported_encoding(&mut self) -> SupportedEncoding {
        if self.has_supported_encoding() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::SupportedEncoding(v)) => v,
                _ => panic!(),
            }
        } else {
            SupportedEncoding::new()
        }
    }

    // uint32 selected_sid = 35;

    pub fn selected_sid(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(misc::Union::SelectedSid(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_selected_sid(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_selected_sid(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SelectedSid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selected_sid(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(misc::Union::SelectedSid(v))
    }

    // .hbb.DisplayResolution change_display_resolution = 36;

    pub fn change_display_resolution(&self) -> &DisplayResolution {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(ref v)) => v,
            _ => <DisplayResolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_change_display_resolution(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_change_display_resolution(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_change_display_resolution(&mut self, v: DisplayResolution) {
        self.union = ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(v))
    }

    // Mutable pointer to the field.
    pub fn mut_change_display_resolution(&mut self) -> &mut DisplayResolution {
        if let ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(DisplayResolution::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_change_display_resolution(&mut self) -> DisplayResolution {
        if self.has_change_display_resolution() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(v)) => v,
                _ => panic!(),
            }
        } else {
            DisplayResolution::new()
        }
    }

    // .hbb.MessageQuery message_query = 37;

    pub fn message_query(&self) -> &MessageQuery {
        match self.union {
            ::std::option::Option::Some(misc::Union::MessageQuery(ref v)) => v,
            _ => <MessageQuery as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_message_query(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_message_query(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::MessageQuery(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_query(&mut self, v: MessageQuery) {
        self.union = ::std::option::Option::Some(misc::Union::MessageQuery(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_query(&mut self) -> &mut MessageQuery {
        if let ::std::option::Option::Some(misc::Union::MessageQuery(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::MessageQuery(MessageQuery::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::MessageQuery(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_query(&mut self) -> MessageQuery {
        if self.has_message_query() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::MessageQuery(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageQuery::new()
        }
    }

    // int32 follow_current_display = 38;

    pub fn follow_current_display(&self) -> i32 {
        match self.union {
            ::std::option::Option::Some(misc::Union::FollowCurrentDisplay(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_follow_current_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_follow_current_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::FollowCurrentDisplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_follow_current_display(&mut self, v: i32) {
        self.union = ::std::option::Option::Some(misc::Union::FollowCurrentDisplay(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(33);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ChatMessage>(
            "chat_message",
            Misc::has_chat_message,
            Misc::chat_message,
            Misc::mut_chat_message,
            Misc::set_chat_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchDisplay>(
            "switch_display",
            Misc::has_switch_display,
            Misc::switch_display,
            Misc::mut_switch_display,
            Misc::set_switch_display,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PermissionInfo>(
            "permission_info",
            Misc::has_permission_info,
            Misc::permission_info,
            Misc::mut_permission_info,
            Misc::set_permission_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OptionMessage>(
            "option",
            Misc::has_option,
            Misc::option,
            Misc::mut_option,
            Misc::set_option,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFormat>(
            "audio_format",
            Misc::has_audio_format,
            Misc::audio_format,
            Misc::mut_audio_format,
            Misc::set_audio_format,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "close_reason",
            Misc::has_close_reason,
            Misc::close_reason,
            Misc::set_close_reason,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "refresh_video",
            Misc::has_refresh_video,
            Misc::refresh_video,
            Misc::set_refresh_video,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "video_received",
            Misc::has_video_received,
            Misc::video_received,
            Misc::set_video_received,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BackNotification>(
            "back_notification",
            Misc::has_back_notification,
            Misc::back_notification,
            Misc::mut_back_notification,
            Misc::set_back_notification,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "restart_remote_device",
            Misc::has_restart_remote_device,
            Misc::restart_remote_device,
            Misc::set_restart_remote_device,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "uac",
            Misc::has_uac,
            Misc::uac,
            Misc::set_uac,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "foreground_window_elevated",
            Misc::has_foreground_window_elevated,
            Misc::foreground_window_elevated,
            Misc::set_foreground_window_elevated,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "stop_service",
            Misc::has_stop_service,
            Misc::stop_service,
            Misc::set_stop_service,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ElevationRequest>(
            "elevation_request",
            Misc::has_elevation_request,
            Misc::elevation_request,
            Misc::mut_elevation_request,
            Misc::set_elevation_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "elevation_response",
            Misc::has_elevation_response,
            Misc::elevation_response,
            Misc::set_elevation_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "portable_service_running",
            Misc::has_portable_service_running,
            Misc::portable_service_running,
            Misc::set_portable_service_running,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchSidesRequest>(
            "switch_sides_request",
            Misc::has_switch_sides_request,
            Misc::switch_sides_request,
            Misc::mut_switch_sides_request,
            Misc::set_switch_sides_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchBack>(
            "switch_back",
            Misc::has_switch_back,
            Misc::switch_back,
            Misc::mut_switch_back,
            Misc::set_switch_back,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Resolution>(
            "change_resolution",
            Misc::has_change_resolution,
            Misc::change_resolution,
            Misc::mut_change_resolution,
            Misc::set_change_resolution,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PluginRequest>(
            "plugin_request",
            Misc::has_plugin_request,
            Misc::plugin_request,
            Misc::mut_plugin_request,
            Misc::set_plugin_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PluginFailure>(
            "plugin_failure",
            Misc::has_plugin_failure,
            Misc::plugin_failure,
            Misc::mut_plugin_failure,
            Misc::set_plugin_failure,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "full_speed_fps",
            Misc::has_full_speed_fps,
            Misc::full_speed_fps,
            Misc::set_full_speed_fps,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "auto_adjust_fps",
            Misc::has_auto_adjust_fps,
            Misc::auto_adjust_fps,
            Misc::set_auto_adjust_fps,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "client_record_status",
            Misc::has_client_record_status,
            Misc::client_record_status,
            Misc::set_client_record_status,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CaptureDisplays>(
            "capture_displays",
            Misc::has_capture_displays,
            Misc::capture_displays,
            Misc::mut_capture_displays,
            Misc::set_capture_displays,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "refresh_video_display",
            Misc::has_refresh_video_display,
            Misc::refresh_video_display,
            Misc::set_refresh_video_display,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ToggleVirtualDisplay>(
            "toggle_virtual_display",
            Misc::has_toggle_virtual_display,
            Misc::toggle_virtual_display,
            Misc::mut_toggle_virtual_display,
            Misc::set_toggle_virtual_display,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TogglePrivacyMode>(
            "toggle_privacy_mode",
            Misc::has_toggle_privacy_mode,
            Misc::toggle_privacy_mode,
            Misc::mut_toggle_privacy_mode,
            Misc::set_toggle_privacy_mode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SupportedEncoding>(
            "supported_encoding",
            Misc::has_supported_encoding,
            Misc::supported_encoding,
            Misc::mut_supported_encoding,
            Misc::set_supported_encoding,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "selected_sid",
            Misc::has_selected_sid,
            Misc::selected_sid,
            Misc::set_selected_sid,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DisplayResolution>(
            "change_display_resolution",
            Misc::has_change_display_resolution,
            Misc::change_display_resolution,
            Misc::mut_change_display_resolution,
            Misc::set_change_display_resolution,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MessageQuery>(
            "message_query",
            Misc::has_message_query,
            Misc::message_query,
            Misc::mut_message_query,
            Misc::set_message_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "follow_current_display",
            Misc::has_follow_current_display,
            Misc::follow_current_display,
            Misc::set_follow_current_display,
        ));
        oneofs.push(misc::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Misc>(
            "Misc",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Misc {
    const NAME: &'static str = "Misc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.union = ::std::option::Option::Some(misc::Union::ChatMessage(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(misc::Union::Option(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(misc::Union::AudioFormat(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(misc::Union::CloseReason(is.read_string()?));
                },
                80 => {
                    self.union = ::std::option::Option::Some(misc::Union::RefreshVideo(is.read_bool()?));
                },
                96 => {
                    self.union = ::std::option::Option::Some(misc::Union::VideoReceived(is.read_bool()?));
                },
                106 => {
                    self.union = ::std::option::Option::Some(misc::Union::BackNotification(is.read_message()?));
                },
                112 => {
                    self.union = ::std::option::Option::Some(misc::Union::RestartRemoteDevice(is.read_bool()?));
                },
                120 => {
                    self.union = ::std::option::Option::Some(misc::Union::Uac(is.read_bool()?));
                },
                128 => {
                    self.union = ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(is.read_bool()?));
                },
                136 => {
                    self.union = ::std::option::Option::Some(misc::Union::StopService(is.read_bool()?));
                },
                146 => {
                    self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(is.read_message()?));
                },
                154 => {
                    self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(is.read_string()?));
                },
                160 => {
                    self.union = ::std::option::Option::Some(misc::Union::PortableServiceRunning(is.read_bool()?));
                },
                170 => {
                    self.union = ::std::option::Option::Some(misc::Union::SwitchSidesRequest(is.read_message()?));
                },
                178 => {
                    self.union = ::std::option::Option::Some(misc::Union::SwitchBack(is.read_message()?));
                },
                194 => {
                    self.union = ::std::option::Option::Some(misc::Union::ChangeResolution(is.read_message()?));
                },
                202 => {
                    self.union = ::std::option::Option::Some(misc::Union::PluginRequest(is.read_message()?));
                },
                210 => {
                    self.union = ::std::option::Option::Some(misc::Union::PluginFailure(is.read_message()?));
                },
                216 => {
                    self.union = ::std::option::Option::Some(misc::Union::FullSpeedFps(is.read_uint32()?));
                },
                224 => {
                    self.union = ::std::option::Option::Some(misc::Union::AutoAdjustFps(is.read_uint32()?));
                },
                232 => {
                    self.union = ::std::option::Option::Some(misc::Union::ClientRecordStatus(is.read_bool()?));
                },
                242 => {
                    self.union = ::std::option::Option::Some(misc::Union::CaptureDisplays(is.read_message()?));
                },
                248 => {
                    self.union = ::std::option::Option::Some(misc::Union::RefreshVideoDisplay(is.read_int32()?));
                },
                258 => {
                    self.union = ::std::option::Option::Some(misc::Union::ToggleVirtualDisplay(is.read_message()?));
                },
                266 => {
                    self.union = ::std::option::Option::Some(misc::Union::TogglePrivacyMode(is.read_message()?));
                },
                274 => {
                    self.union = ::std::option::Option::Some(misc::Union::SupportedEncoding(is.read_message()?));
                },
                280 => {
                    self.union = ::std::option::Option::Some(misc::Union::SelectedSid(is.read_uint32()?));
                },
                290 => {
                    self.union = ::std::option::Option::Some(misc::Union::ChangeDisplayResolution(is.read_message()?));
                },
                298 => {
                    self.union = ::std::option::Option::Some(misc::Union::MessageQuery(is.read_message()?));
                },
                304 => {
                    self.union = ::std::option::Option::Some(misc::Union::FollowCurrentDisplay(is.read_int32()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::ChatMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::SwitchDisplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::PermissionInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::Option(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::AudioFormat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::CloseReason(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &misc::Union::RefreshVideo(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::VideoReceived(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::BackNotification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::RestartRemoteDevice(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::Uac(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::ForegroundWindowElevated(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::StopService(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::ElevationRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::ElevationResponse(ref v) => {
                    my_size += ::protobuf::rt::string_size(19, &v);
                },
                &misc::Union::PortableServiceRunning(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::SwitchSidesRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::SwitchBack(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::ChangeResolution(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::PluginRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::PluginFailure(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::FullSpeedFps(v) => {
                    my_size += ::protobuf::rt::uint32_size(27, v);
                },
                &misc::Union::AutoAdjustFps(v) => {
                    my_size += ::protobuf::rt::uint32_size(28, v);
                },
                &misc::Union::ClientRecordStatus(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::CaptureDisplays(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::RefreshVideoDisplay(v) => {
                    my_size += ::protobuf::rt::int32_size(31, v);
                },
                &misc::Union::ToggleVirtualDisplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::TogglePrivacyMode(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::SupportedEncoding(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::SelectedSid(v) => {
                    my_size += ::protobuf::rt::uint32_size(35, v);
                },
                &misc::Union::ChangeDisplayResolution(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::MessageQuery(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::FollowCurrentDisplay(v) => {
                    my_size += ::protobuf::rt::int32_size(38, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::ChatMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &misc::Union::SwitchDisplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &misc::Union::PermissionInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &misc::Union::Option(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &misc::Union::AudioFormat(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &misc::Union::CloseReason(ref v) => {
                    os.write_string(9, v)?;
                },
                &misc::Union::RefreshVideo(v) => {
                    os.write_bool(10, v)?;
                },
                &misc::Union::VideoReceived(v) => {
                    os.write_bool(12, v)?;
                },
                &misc::Union::BackNotification(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &misc::Union::RestartRemoteDevice(v) => {
                    os.write_bool(14, v)?;
                },
                &misc::Union::Uac(v) => {
                    os.write_bool(15, v)?;
                },
                &misc::Union::ForegroundWindowElevated(v) => {
                    os.write_bool(16, v)?;
                },
                &misc::Union::StopService(v) => {
                    os.write_bool(17, v)?;
                },
                &misc::Union::ElevationRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &misc::Union::ElevationResponse(ref v) => {
                    os.write_string(19, v)?;
                },
                &misc::Union::PortableServiceRunning(v) => {
                    os.write_bool(20, v)?;
                },
                &misc::Union::SwitchSidesRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &misc::Union::SwitchBack(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &misc::Union::ChangeResolution(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                },
                &misc::Union::PluginRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                },
                &misc::Union::PluginFailure(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                },
                &misc::Union::FullSpeedFps(v) => {
                    os.write_uint32(27, v)?;
                },
                &misc::Union::AutoAdjustFps(v) => {
                    os.write_uint32(28, v)?;
                },
                &misc::Union::ClientRecordStatus(v) => {
                    os.write_bool(29, v)?;
                },
                &misc::Union::CaptureDisplays(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                },
                &misc::Union::RefreshVideoDisplay(v) => {
                    os.write_int32(31, v)?;
                },
                &misc::Union::ToggleVirtualDisplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
                },
                &misc::Union::TogglePrivacyMode(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                },
                &misc::Union::SupportedEncoding(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
                },
                &misc::Union::SelectedSid(v) => {
                    os.write_uint32(35, v)?;
                },
                &misc::Union::ChangeDisplayResolution(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
                },
                &misc::Union::MessageQuery(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
                },
                &misc::Union::FollowCurrentDisplay(v) => {
                    os.write_int32(38, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Misc {
        Misc::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Misc {
        static instance: Misc = Misc {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Misc {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Misc").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Misc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Misc {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Misc`
pub mod misc {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Misc.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Misc.chat_message)
        ChatMessage(super::ChatMessage),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.switch_display)
        SwitchDisplay(super::SwitchDisplay),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.permission_info)
        PermissionInfo(super::PermissionInfo),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.option)
        Option(super::OptionMessage),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.audio_format)
        AudioFormat(super::AudioFormat),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.close_reason)
        CloseReason(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.refresh_video)
        RefreshVideo(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.video_received)
        VideoReceived(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.back_notification)
        BackNotification(super::BackNotification),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.restart_remote_device)
        RestartRemoteDevice(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.uac)
        Uac(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.foreground_window_elevated)
        ForegroundWindowElevated(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.stop_service)
        StopService(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.elevation_request)
        ElevationRequest(super::ElevationRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.elevation_response)
        ElevationResponse(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.portable_service_running)
        PortableServiceRunning(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.switch_sides_request)
        SwitchSidesRequest(super::SwitchSidesRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.switch_back)
        SwitchBack(super::SwitchBack),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.change_resolution)
        ChangeResolution(super::Resolution),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.plugin_request)
        PluginRequest(super::PluginRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.plugin_failure)
        PluginFailure(super::PluginFailure),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.full_speed_fps)
        FullSpeedFps(u32),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.auto_adjust_fps)
        AutoAdjustFps(u32),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.client_record_status)
        ClientRecordStatus(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.capture_displays)
        CaptureDisplays(super::CaptureDisplays),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.refresh_video_display)
        RefreshVideoDisplay(i32),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.toggle_virtual_display)
        ToggleVirtualDisplay(super::ToggleVirtualDisplay),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.toggle_privacy_mode)
        TogglePrivacyMode(super::TogglePrivacyMode),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.supported_encoding)
        SupportedEncoding(super::SupportedEncoding),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.selected_sid)
        SelectedSid(u32),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.change_display_resolution)
        ChangeDisplayResolution(super::DisplayResolution),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.message_query)
        MessageQuery(super::MessageQuery),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.follow_current_display)
        FollowCurrentDisplay(i32),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Misc as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

// @@protoc_insertion_point(message:hbb.VoiceCallRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceCallRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.VoiceCallRequest.req_timestamp)
    pub req_timestamp: i64,
    // @@protoc_insertion_point(field:hbb.VoiceCallRequest.is_connect)
    pub is_connect: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.VoiceCallRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceCallRequest {
    fn default() -> &'a VoiceCallRequest {
        <VoiceCallRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoiceCallRequest {
    pub fn new() -> VoiceCallRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "req_timestamp",
            |m: &VoiceCallRequest| { &m.req_timestamp },
            |m: &mut VoiceCallRequest| { &mut m.req_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_connect",
            |m: &VoiceCallRequest| { &m.is_connect },
            |m: &mut VoiceCallRequest| { &mut m.is_connect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceCallRequest>(
            "VoiceCallRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceCallRequest {
    const NAME: &'static str = "VoiceCallRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.req_timestamp = is.read_int64()?;
                },
                16 => {
                    self.is_connect = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.req_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.req_timestamp);
        }
        if self.is_connect != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.req_timestamp != 0 {
            os.write_int64(1, self.req_timestamp)?;
        }
        if self.is_connect != false {
            os.write_bool(2, self.is_connect)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceCallRequest {
        VoiceCallRequest::new()
    }

    fn clear(&mut self) {
        self.req_timestamp = 0;
        self.is_connect = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceCallRequest {
        static instance: VoiceCallRequest = VoiceCallRequest {
            req_timestamp: 0,
            is_connect: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceCallRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceCallRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceCallRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceCallRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.VoiceCallResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceCallResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.VoiceCallResponse.accepted)
    pub accepted: bool,
    // @@protoc_insertion_point(field:hbb.VoiceCallResponse.req_timestamp)
    pub req_timestamp: i64,
    // @@protoc_insertion_point(field:hbb.VoiceCallResponse.ack_timestamp)
    pub ack_timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.VoiceCallResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceCallResponse {
    fn default() -> &'a VoiceCallResponse {
        <VoiceCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl VoiceCallResponse {
    pub fn new() -> VoiceCallResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accepted",
            |m: &VoiceCallResponse| { &m.accepted },
            |m: &mut VoiceCallResponse| { &mut m.accepted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "req_timestamp",
            |m: &VoiceCallResponse| { &m.req_timestamp },
            |m: &mut VoiceCallResponse| { &mut m.req_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_timestamp",
            |m: &VoiceCallResponse| { &m.ack_timestamp },
            |m: &mut VoiceCallResponse| { &mut m.ack_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceCallResponse>(
            "VoiceCallResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceCallResponse {
    const NAME: &'static str = "VoiceCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accepted = is.read_bool()?;
                },
                16 => {
                    self.req_timestamp = is.read_int64()?;
                },
                24 => {
                    self.ack_timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.accepted != false {
            my_size += 1 + 1;
        }
        if self.req_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.req_timestamp);
        }
        if self.ack_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.ack_timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.accepted != false {
            os.write_bool(1, self.accepted)?;
        }
        if self.req_timestamp != 0 {
            os.write_int64(2, self.req_timestamp)?;
        }
        if self.ack_timestamp != 0 {
            os.write_int64(3, self.ack_timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceCallResponse {
        VoiceCallResponse::new()
    }

    fn clear(&mut self) {
        self.accepted = false;
        self.req_timestamp = 0;
        self.ack_timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceCallResponse {
        static instance: VoiceCallResponse = VoiceCallResponse {
            accepted: false,
            req_timestamp: 0,
            ack_timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceCallResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceCallResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hbb.Message)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Message {
    // message oneof groups
    pub union: ::std::option::Option<message::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .hbb.SignedId signed_id = 3;

    pub fn signed_id(&self) -> &SignedId {
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(ref v)) => v,
            _ => <SignedId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_signed_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_id(&mut self, v: SignedId) {
        self.union = ::std::option::Option::Some(message::Union::SignedId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_id(&mut self) -> &mut SignedId {
        if let ::std::option::Option::Some(message::Union::SignedId(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::SignedId(SignedId::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_id(&mut self) -> SignedId {
        if self.has_signed_id() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::SignedId(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedId::new()
        }
    }

    // .hbb.PublicKey public_key = 4;

    pub fn public_key(&self) -> &PublicKey {
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(ref v)) => v,
            _ => <PublicKey as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_public_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: PublicKey) {
        self.union = ::std::option::Option::Some(message::Union::PublicKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_public_key(&mut self) -> &mut PublicKey {
        if let ::std::option::Option::Some(message::Union::PublicKey(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::PublicKey(PublicKey::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_public_key(&mut self) -> PublicKey {
        if self.has_public_key() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::PublicKey(v)) => v,
                _ => panic!(),
            }
        } else {
            PublicKey::new()
        }
    }

    // .hbb.TestDelay test_delay = 5;

    pub fn test_delay(&self) -> &TestDelay {
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(ref v)) => v,
            _ => <TestDelay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_test_delay(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_test_delay(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_delay(&mut self, v: TestDelay) {
        self.union = ::std::option::Option::Some(message::Union::TestDelay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_delay(&mut self) -> &mut TestDelay {
        if let ::std::option::Option::Some(message::Union::TestDelay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::TestDelay(TestDelay::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_delay(&mut self) -> TestDelay {
        if self.has_test_delay() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::TestDelay(v)) => v,
                _ => panic!(),
            }
        } else {
            TestDelay::new()
        }
    }

    // .hbb.VideoFrame video_frame = 6;

    pub fn video_frame(&self) -> &VideoFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(ref v)) => v,
            _ => <VideoFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_video_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_video_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video_frame(&mut self, v: VideoFrame) {
        self.union = ::std::option::Option::Some(message::Union::VideoFrame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_video_frame(&mut self) -> &mut VideoFrame {
        if let ::std::option::Option::Some(message::Union::VideoFrame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::VideoFrame(VideoFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_video_frame(&mut self) -> VideoFrame {
        if self.has_video_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::VideoFrame(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoFrame::new()
        }
    }

    // .hbb.LoginRequest login_request = 7;

    pub fn login_request(&self) -> &LoginRequest {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(ref v)) => v,
            _ => <LoginRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_request(&mut self, v: LoginRequest) {
        self.union = ::std::option::Option::Some(message::Union::LoginRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_request(&mut self) -> &mut LoginRequest {
        if let ::std::option::Option::Some(message::Union::LoginRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::LoginRequest(LoginRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_request(&mut self) -> LoginRequest {
        if self.has_login_request() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::LoginRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginRequest::new()
        }
    }

    // .hbb.LoginResponse login_response = 8;

    pub fn login_response(&self) -> &LoginResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(ref v)) => v,
            _ => <LoginResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_response(&mut self, v: LoginResponse) {
        self.union = ::std::option::Option::Some(message::Union::LoginResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_response(&mut self) -> &mut LoginResponse {
        if let ::std::option::Option::Some(message::Union::LoginResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::LoginResponse(LoginResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_response(&mut self) -> LoginResponse {
        if self.has_login_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::LoginResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginResponse::new()
        }
    }

    // .hbb.Hash hash = 9;

    pub fn hash(&self) -> &Hash {
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(ref v)) => v,
            _ => <Hash as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hash(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: Hash) {
        self.union = ::std::option::Option::Some(message::Union::Hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash(&mut self) -> &mut Hash {
        if let ::std::option::Option::Some(message::Union::Hash(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Hash(Hash::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash(&mut self) -> Hash {
        if self.has_hash() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Hash(v)) => v,
                _ => panic!(),
            }
        } else {
            Hash::new()
        }
    }

    // .hbb.MouseEvent mouse_event = 10;

    pub fn mouse_event(&self) -> &MouseEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(ref v)) => v,
            _ => <MouseEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_mouse_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_event(&mut self, v: MouseEvent) {
        self.union = ::std::option::Option::Some(message::Union::MouseEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_event(&mut self) -> &mut MouseEvent {
        if let ::std::option::Option::Some(message::Union::MouseEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::MouseEvent(MouseEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_event(&mut self) -> MouseEvent {
        if self.has_mouse_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::MouseEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            MouseEvent::new()
        }
    }

    // .hbb.AudioFrame audio_frame = 11;

    pub fn audio_frame(&self) -> &AudioFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(ref v)) => v,
            _ => <AudioFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_frame(&mut self, v: AudioFrame) {
        self.union = ::std::option::Option::Some(message::Union::AudioFrame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_frame(&mut self) -> &mut AudioFrame {
        if let ::std::option::Option::Some(message::Union::AudioFrame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::AudioFrame(AudioFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_frame(&mut self) -> AudioFrame {
        if self.has_audio_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::AudioFrame(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFrame::new()
        }
    }

    // .hbb.CursorData cursor_data = 12;

    pub fn cursor_data(&self) -> &CursorData {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(ref v)) => v,
            _ => <CursorData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_data(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_data(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_data(&mut self, v: CursorData) {
        self.union = ::std::option::Option::Some(message::Union::CursorData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_data(&mut self) -> &mut CursorData {
        if let ::std::option::Option::Some(message::Union::CursorData(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::CursorData(CursorData::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_data(&mut self) -> CursorData {
        if self.has_cursor_data() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::CursorData(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorData::new()
        }
    }

    // .hbb.CursorPosition cursor_position = 13;

    pub fn cursor_position(&self) -> &CursorPosition {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(ref v)) => v,
            _ => <CursorPosition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_position(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_position(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_position(&mut self, v: CursorPosition) {
        self.union = ::std::option::Option::Some(message::Union::CursorPosition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_position(&mut self) -> &mut CursorPosition {
        if let ::std::option::Option::Some(message::Union::CursorPosition(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::CursorPosition(CursorPosition::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_position(&mut self) -> CursorPosition {
        if self.has_cursor_position() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::CursorPosition(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorPosition::new()
        }
    }

    // uint64 cursor_id = 14;

    pub fn cursor_id(&self) -> u64 {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorId(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cursor_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.union = ::std::option::Option::Some(message::Union::CursorId(v))
    }

    // .hbb.KeyEvent key_event = 15;

    pub fn key_event(&self) -> &KeyEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(ref v)) => v,
            _ => <KeyEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_key_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_key_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_event(&mut self, v: KeyEvent) {
        self.union = ::std::option::Option::Some(message::Union::KeyEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_event(&mut self) -> &mut KeyEvent {
        if let ::std::option::Option::Some(message::Union::KeyEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::KeyEvent(KeyEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_event(&mut self) -> KeyEvent {
        if self.has_key_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::KeyEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyEvent::new()
        }
    }

    // .hbb.Clipboard clipboard = 16;

    pub fn clipboard(&self) -> &Clipboard {
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(ref v)) => v,
            _ => <Clipboard as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clipboard(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_clipboard(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clipboard(&mut self, v: Clipboard) {
        self.union = ::std::option::Option::Some(message::Union::Clipboard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clipboard(&mut self) -> &mut Clipboard {
        if let ::std::option::Option::Some(message::Union::Clipboard(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Clipboard(Clipboard::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clipboard(&mut self) -> Clipboard {
        if self.has_clipboard() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Clipboard(v)) => v,
                _ => panic!(),
            }
        } else {
            Clipboard::new()
        }
    }

    // .hbb.FileAction file_action = 17;

    pub fn file_action(&self) -> &FileAction {
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(ref v)) => v,
            _ => <FileAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_action(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_action(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_action(&mut self, v: FileAction) {
        self.union = ::std::option::Option::Some(message::Union::FileAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_action(&mut self) -> &mut FileAction {
        if let ::std::option::Option::Some(message::Union::FileAction(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::FileAction(FileAction::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_action(&mut self) -> FileAction {
        if self.has_file_action() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::FileAction(v)) => v,
                _ => panic!(),
            }
        } else {
            FileAction::new()
        }
    }

    // .hbb.FileResponse file_response = 18;

    pub fn file_response(&self) -> &FileResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(ref v)) => v,
            _ => <FileResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_response(&mut self, v: FileResponse) {
        self.union = ::std::option::Option::Some(message::Union::FileResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_response(&mut self) -> &mut FileResponse {
        if let ::std::option::Option::Some(message::Union::FileResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::FileResponse(FileResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_response(&mut self) -> FileResponse {
        if self.has_file_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::FileResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            FileResponse::new()
        }
    }

    // .hbb.Misc misc = 19;

    pub fn misc(&self) -> &Misc {
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(ref v)) => v,
            _ => <Misc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_misc(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_misc(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_misc(&mut self, v: Misc) {
        self.union = ::std::option::Option::Some(message::Union::Misc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_misc(&mut self) -> &mut Misc {
        if let ::std::option::Option::Some(message::Union::Misc(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Misc(Misc::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_misc(&mut self) -> Misc {
        if self.has_misc() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Misc(v)) => v,
                _ => panic!(),
            }
        } else {
            Misc::new()
        }
    }

    // .hbb.Cliprdr cliprdr = 20;

    pub fn cliprdr(&self) -> &Cliprdr {
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(ref v)) => v,
            _ => <Cliprdr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cliprdr(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cliprdr(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cliprdr(&mut self, v: Cliprdr) {
        self.union = ::std::option::Option::Some(message::Union::Cliprdr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cliprdr(&mut self) -> &mut Cliprdr {
        if let ::std::option::Option::Some(message::Union::Cliprdr(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Cliprdr(Cliprdr::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cliprdr(&mut self) -> Cliprdr {
        if self.has_cliprdr() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Cliprdr(v)) => v,
                _ => panic!(),
            }
        } else {
            Cliprdr::new()
        }
    }

    // .hbb.MessageBox message_box = 21;

    pub fn message_box(&self) -> &MessageBox {
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(ref v)) => v,
            _ => <MessageBox as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_message_box(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_message_box(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_box(&mut self, v: MessageBox) {
        self.union = ::std::option::Option::Some(message::Union::MessageBox(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_box(&mut self) -> &mut MessageBox {
        if let ::std::option::Option::Some(message::Union::MessageBox(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::MessageBox(MessageBox::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_box(&mut self) -> MessageBox {
        if self.has_message_box() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::MessageBox(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageBox::new()
        }
    }

    // .hbb.SwitchSidesResponse switch_sides_response = 22;

    pub fn switch_sides_response(&self) -> &SwitchSidesResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::SwitchSidesResponse(ref v)) => v,
            _ => <SwitchSidesResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_sides_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_sides_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::SwitchSidesResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_sides_response(&mut self, v: SwitchSidesResponse) {
        self.union = ::std::option::Option::Some(message::Union::SwitchSidesResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_sides_response(&mut self) -> &mut SwitchSidesResponse {
        if let ::std::option::Option::Some(message::Union::SwitchSidesResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::SwitchSidesResponse(SwitchSidesResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::SwitchSidesResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_sides_response(&mut self) -> SwitchSidesResponse {
        if self.has_switch_sides_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::SwitchSidesResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchSidesResponse::new()
        }
    }

    // .hbb.VoiceCallRequest voice_call_request = 23;

    pub fn voice_call_request(&self) -> &VoiceCallRequest {
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallRequest(ref v)) => v,
            _ => <VoiceCallRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_voice_call_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_voice_call_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_voice_call_request(&mut self, v: VoiceCallRequest) {
        self.union = ::std::option::Option::Some(message::Union::VoiceCallRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_voice_call_request(&mut self) -> &mut VoiceCallRequest {
        if let ::std::option::Option::Some(message::Union::VoiceCallRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::VoiceCallRequest(VoiceCallRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_voice_call_request(&mut self) -> VoiceCallRequest {
        if self.has_voice_call_request() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::VoiceCallRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            VoiceCallRequest::new()
        }
    }

    // .hbb.VoiceCallResponse voice_call_response = 24;

    pub fn voice_call_response(&self) -> &VoiceCallResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallResponse(ref v)) => v,
            _ => <VoiceCallResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_voice_call_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_voice_call_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_voice_call_response(&mut self, v: VoiceCallResponse) {
        self.union = ::std::option::Option::Some(message::Union::VoiceCallResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_voice_call_response(&mut self) -> &mut VoiceCallResponse {
        if let ::std::option::Option::Some(message::Union::VoiceCallResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::VoiceCallResponse(VoiceCallResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::VoiceCallResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_voice_call_response(&mut self) -> VoiceCallResponse {
        if self.has_voice_call_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::VoiceCallResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            VoiceCallResponse::new()
        }
    }

    // .hbb.PeerInfo peer_info = 25;

    pub fn peer_info(&self) -> &PeerInfo {
        match self.union {
            ::std::option::Option::Some(message::Union::PeerInfo(ref v)) => v,
            _ => <PeerInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peer_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_peer_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::PeerInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_info(&mut self, v: PeerInfo) {
        self.union = ::std::option::Option::Some(message::Union::PeerInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peer_info(&mut self) -> &mut PeerInfo {
        if let ::std::option::Option::Some(message::Union::PeerInfo(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::PeerInfo(PeerInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::PeerInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_info(&mut self) -> PeerInfo {
        if self.has_peer_info() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::PeerInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PeerInfo::new()
        }
    }

    // .hbb.PointerDeviceEvent pointer_device_event = 26;

    pub fn pointer_device_event(&self) -> &PointerDeviceEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::PointerDeviceEvent(ref v)) => v,
            _ => <PointerDeviceEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pointer_device_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_pointer_device_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::PointerDeviceEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pointer_device_event(&mut self, v: PointerDeviceEvent) {
        self.union = ::std::option::Option::Some(message::Union::PointerDeviceEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pointer_device_event(&mut self) -> &mut PointerDeviceEvent {
        if let ::std::option::Option::Some(message::Union::PointerDeviceEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::PointerDeviceEvent(PointerDeviceEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::PointerDeviceEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pointer_device_event(&mut self) -> PointerDeviceEvent {
        if self.has_pointer_device_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::PointerDeviceEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            PointerDeviceEvent::new()
        }
    }

    // .hbb.Auth2FA auth_2fa = 27;

    pub fn auth_2fa(&self) -> &Auth2FA {
        match self.union {
            ::std::option::Option::Some(message::Union::Auth2fa(ref v)) => v,
            _ => <Auth2FA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_auth_2fa(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_auth_2fa(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Auth2fa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auth_2fa(&mut self, v: Auth2FA) {
        self.union = ::std::option::Option::Some(message::Union::Auth2fa(v))
    }

    // Mutable pointer to the field.
    pub fn mut_auth_2fa(&mut self) -> &mut Auth2FA {
        if let ::std::option::Option::Some(message::Union::Auth2fa(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Auth2fa(Auth2FA::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Auth2fa(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_auth_2fa(&mut self) -> Auth2FA {
        if self.has_auth_2fa() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Auth2fa(v)) => v,
                _ => panic!(),
            }
        } else {
            Auth2FA::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedId>(
            "signed_id",
            Message::has_signed_id,
            Message::signed_id,
            Message::mut_signed_id,
            Message::set_signed_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PublicKey>(
            "public_key",
            Message::has_public_key,
            Message::public_key,
            Message::mut_public_key,
            Message::set_public_key,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TestDelay>(
            "test_delay",
            Message::has_test_delay,
            Message::test_delay,
            Message::mut_test_delay,
            Message::set_test_delay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoFrame>(
            "video_frame",
            Message::has_video_frame,
            Message::video_frame,
            Message::mut_video_frame,
            Message::set_video_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginRequest>(
            "login_request",
            Message::has_login_request,
            Message::login_request,
            Message::mut_login_request,
            Message::set_login_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginResponse>(
            "login_response",
            Message::has_login_response,
            Message::login_response,
            Message::mut_login_response,
            Message::set_login_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Hash>(
            "hash",
            Message::has_hash,
            Message::hash,
            Message::mut_hash,
            Message::set_hash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MouseEvent>(
            "mouse_event",
            Message::has_mouse_event,
            Message::mouse_event,
            Message::mut_mouse_event,
            Message::set_mouse_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFrame>(
            "audio_frame",
            Message::has_audio_frame,
            Message::audio_frame,
            Message::mut_audio_frame,
            Message::set_audio_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorData>(
            "cursor_data",
            Message::has_cursor_data,
            Message::cursor_data,
            Message::mut_cursor_data,
            Message::set_cursor_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorPosition>(
            "cursor_position",
            Message::has_cursor_position,
            Message::cursor_position,
            Message::mut_cursor_position,
            Message::set_cursor_position,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cursor_id",
            Message::has_cursor_id,
            Message::cursor_id,
            Message::set_cursor_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeyEvent>(
            "key_event",
            Message::has_key_event,
            Message::key_event,
            Message::mut_key_event,
            Message::set_key_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Clipboard>(
            "clipboard",
            Message::has_clipboard,
            Message::clipboard,
            Message::mut_clipboard,
            Message::set_clipboard,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileAction>(
            "file_action",
            Message::has_file_action,
            Message::file_action,
            Message::mut_file_action,
            Message::set_file_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileResponse>(
            "file_response",
            Message::has_file_response,
            Message::file_response,
            Message::mut_file_response,
            Message::set_file_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Misc>(
            "misc",
            Message::has_misc,
            Message::misc,
            Message::mut_misc,
            Message::set_misc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Cliprdr>(
            "cliprdr",
            Message::has_cliprdr,
            Message::cliprdr,
            Message::mut_cliprdr,
            Message::set_cliprdr,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MessageBox>(
            "message_box",
            Message::has_message_box,
            Message::message_box,
            Message::mut_message_box,
            Message::set_message_box,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchSidesResponse>(
            "switch_sides_response",
            Message::has_switch_sides_response,
            Message::switch_sides_response,
            Message::mut_switch_sides_response,
            Message::set_switch_sides_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VoiceCallRequest>(
            "voice_call_request",
            Message::has_voice_call_request,
            Message::voice_call_request,
            Message::mut_voice_call_request,
            Message::set_voice_call_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VoiceCallResponse>(
            "voice_call_response",
            Message::has_voice_call_response,
            Message::voice_call_response,
            Message::mut_voice_call_response,
            Message::set_voice_call_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeerInfo>(
            "peer_info",
            Message::has_peer_info,
            Message::peer_info,
            Message::mut_peer_info,
            Message::set_peer_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PointerDeviceEvent>(
            "pointer_device_event",
            Message::has_pointer_device_event,
            Message::pointer_device_event,
            Message::mut_pointer_device_event,
            Message::set_pointer_device_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Auth2FA>(
            "auth_2fa",
            Message::has_auth_2fa,
            Message::auth_2fa,
            Message::mut_auth_2fa,
            Message::set_auth_2fa,
        ));
        oneofs.push(message::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.union = ::std::option::Option::Some(message::Union::SignedId(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(message::Union::PublicKey(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(message::Union::TestDelay(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(message::Union::VideoFrame(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(message::Union::LoginRequest(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(message::Union::LoginResponse(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(message::Union::Hash(is.read_message()?));
                },
                82 => {
                    self.union = ::std::option::Option::Some(message::Union::MouseEvent(is.read_message()?));
                },
                90 => {
                    self.union = ::std::option::Option::Some(message::Union::AudioFrame(is.read_message()?));
                },
                98 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorData(is.read_message()?));
                },
                106 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorPosition(is.read_message()?));
                },
                112 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorId(is.read_uint64()?));
                },
                122 => {
                    self.union = ::std::option::Option::Some(message::Union::KeyEvent(is.read_message()?));
                },
                130 => {
                    self.union = ::std::option::Option::Some(message::Union::Clipboard(is.read_message()?));
                },
                138 => {
                    self.union = ::std::option::Option::Some(message::Union::FileAction(is.read_message()?));
                },
                146 => {
                    self.union = ::std::option::Option::Some(message::Union::FileResponse(is.read_message()?));
                },
                154 => {
                    self.union = ::std::option::Option::Some(message::Union::Misc(is.read_message()?));
                },
                162 => {
                    self.union = ::std::option::Option::Some(message::Union::Cliprdr(is.read_message()?));
                },
                170 => {
                    self.union = ::std::option::Option::Some(message::Union::MessageBox(is.read_message()?));
                },
                178 => {
                    self.union = ::std::option::Option::Some(message::Union::SwitchSidesResponse(is.read_message()?));
                },
                186 => {
                    self.union = ::std::option::Option::Some(message::Union::VoiceCallRequest(is.read_message()?));
                },
                194 => {
                    self.union = ::std::option::Option::Some(message::Union::VoiceCallResponse(is.read_message()?));
                },
                202 => {
                    self.union = ::std::option::Option::Some(message::Union::PeerInfo(is.read_message()?));
                },
                210 => {
                    self.union = ::std::option::Option::Some(message::Union::PointerDeviceEvent(is.read_message()?));
                },
                218 => {
                    self.union = ::std::option::Option::Some(message::Union::Auth2fa(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::SignedId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::PublicKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::TestDelay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::VideoFrame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::LoginRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::LoginResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Hash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::MouseEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::AudioFrame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorPosition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorId(v) => {
                    my_size += ::protobuf::rt::uint64_size(14, v);
                },
                &message::Union::KeyEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Clipboard(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::FileAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::FileResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Misc(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Cliprdr(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::MessageBox(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::SwitchSidesResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::VoiceCallRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::VoiceCallResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::PeerInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::PointerDeviceEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Auth2fa(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::SignedId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Union::PublicKey(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Union::TestDelay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message::Union::VideoFrame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message::Union::LoginRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message::Union::LoginResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &message::Union::Hash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &message::Union::MouseEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &message::Union::AudioFrame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &message::Union::CursorData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &message::Union::CursorPosition(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &message::Union::CursorId(v) => {
                    os.write_uint64(14, v)?;
                },
                &message::Union::KeyEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &message::Union::Clipboard(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &message::Union::FileAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &message::Union::FileResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &message::Union::Misc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &message::Union::Cliprdr(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &message::Union::MessageBox(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &message::Union::SwitchSidesResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &message::Union::VoiceCallRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                },
                &message::Union::VoiceCallResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                },
                &message::Union::PeerInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                },
                &message::Union::PointerDeviceEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                },
                &message::Union::Auth2fa(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Message.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Message.signed_id)
        SignedId(super::SignedId),
        // @@protoc_insertion_point(oneof_field:hbb.Message.public_key)
        PublicKey(super::PublicKey),
        // @@protoc_insertion_point(oneof_field:hbb.Message.test_delay)
        TestDelay(super::TestDelay),
        // @@protoc_insertion_point(oneof_field:hbb.Message.video_frame)
        VideoFrame(super::VideoFrame),
        // @@protoc_insertion_point(oneof_field:hbb.Message.login_request)
        LoginRequest(super::LoginRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Message.login_response)
        LoginResponse(super::LoginResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.hash)
        Hash(super::Hash),
        // @@protoc_insertion_point(oneof_field:hbb.Message.mouse_event)
        MouseEvent(super::MouseEvent),
        // @@protoc_insertion_point(oneof_field:hbb.Message.audio_frame)
        AudioFrame(super::AudioFrame),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_data)
        CursorData(super::CursorData),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_position)
        CursorPosition(super::CursorPosition),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_id)
        CursorId(u64),
        // @@protoc_insertion_point(oneof_field:hbb.Message.key_event)
        KeyEvent(super::KeyEvent),
        // @@protoc_insertion_point(oneof_field:hbb.Message.clipboard)
        Clipboard(super::Clipboard),
        // @@protoc_insertion_point(oneof_field:hbb.Message.file_action)
        FileAction(super::FileAction),
        // @@protoc_insertion_point(oneof_field:hbb.Message.file_response)
        FileResponse(super::FileResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.misc)
        Misc(super::Misc),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cliprdr)
        Cliprdr(super::Cliprdr),
        // @@protoc_insertion_point(oneof_field:hbb.Message.message_box)
        MessageBox(super::MessageBox),
        // @@protoc_insertion_point(oneof_field:hbb.Message.switch_sides_response)
        SwitchSidesResponse(super::SwitchSidesResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.voice_call_request)
        VoiceCallRequest(super::VoiceCallRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Message.voice_call_response)
        VoiceCallResponse(super::VoiceCallResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.peer_info)
        PeerInfo(super::PeerInfo),
        // @@protoc_insertion_point(oneof_field:hbb.Message.pointer_device_event)
        PointerDeviceEvent(super::PointerDeviceEvent),
        // @@protoc_insertion_point(oneof_field:hbb.Message.auth_2fa)
        Auth2fa(super::Auth2FA),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.Chroma)
pub enum Chroma {
    // @@protoc_insertion_point(enum_value:hbb.Chroma.I420)
    I420 = 0,
    // @@protoc_insertion_point(enum_value:hbb.Chroma.I444)
    I444 = 1,
}

impl ::protobuf::Enum for Chroma {
    const NAME: &'static str = "Chroma";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Chroma> {
        match value {
            0 => ::std::option::Option::Some(Chroma::I420),
            1 => ::std::option::Option::Some(Chroma::I444),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Chroma> {
        match str {
            "I420" => ::std::option::Option::Some(Chroma::I420),
            "I444" => ::std::option::Option::Some(Chroma::I444),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Chroma] = &[
        Chroma::I420,
        Chroma::I444,
    ];
}

impl ::protobuf::EnumFull for Chroma {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Chroma").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Chroma {
    fn default() -> Self {
        Chroma::I420
    }
}

impl Chroma {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Chroma>("Chroma")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.KeyboardMode)
pub enum KeyboardMode {
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Legacy)
    Legacy = 0,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Map)
    Map = 1,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Translate)
    Translate = 2,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Auto)
    Auto = 3,
}

impl ::protobuf::Enum for KeyboardMode {
    const NAME: &'static str = "KeyboardMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyboardMode> {
        match value {
            0 => ::std::option::Option::Some(KeyboardMode::Legacy),
            1 => ::std::option::Option::Some(KeyboardMode::Map),
            2 => ::std::option::Option::Some(KeyboardMode::Translate),
            3 => ::std::option::Option::Some(KeyboardMode::Auto),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<KeyboardMode> {
        match str {
            "Legacy" => ::std::option::Option::Some(KeyboardMode::Legacy),
            "Map" => ::std::option::Option::Some(KeyboardMode::Map),
            "Translate" => ::std::option::Option::Some(KeyboardMode::Translate),
            "Auto" => ::std::option::Option::Some(KeyboardMode::Auto),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyboardMode] = &[
        KeyboardMode::Legacy,
        KeyboardMode::Map,
        KeyboardMode::Translate,
        KeyboardMode::Auto,
    ];
}

impl ::protobuf::EnumFull for KeyboardMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyboardMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeyboardMode {
    fn default() -> Self {
        KeyboardMode::Legacy
    }
}

impl KeyboardMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyboardMode>("KeyboardMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.ControlKey)
pub enum ControlKey {
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Alt)
    Alt = 1,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Backspace)
    Backspace = 2,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.CapsLock)
    CapsLock = 3,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Control)
    Control = 4,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Delete)
    Delete = 5,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.DownArrow)
    DownArrow = 6,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.End)
    End = 7,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Escape)
    Escape = 8,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F1)
    F1 = 9,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F10)
    F10 = 10,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F11)
    F11 = 11,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F12)
    F12 = 12,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F2)
    F2 = 13,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F3)
    F3 = 14,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F4)
    F4 = 15,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F5)
    F5 = 16,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F6)
    F6 = 17,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F7)
    F7 = 18,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F8)
    F8 = 19,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F9)
    F9 = 20,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Home)
    Home = 21,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.LeftArrow)
    LeftArrow = 22,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Meta)
    Meta = 23,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Option)
    Option = 24,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.PageDown)
    PageDown = 25,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.PageUp)
    PageUp = 26,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Return)
    Return = 27,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RightArrow)
    RightArrow = 28,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Shift)
    Shift = 29,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Space)
    Space = 30,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Tab)
    Tab = 31,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.UpArrow)
    UpArrow = 32,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad0)
    Numpad0 = 33,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad1)
    Numpad1 = 34,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad2)
    Numpad2 = 35,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad3)
    Numpad3 = 36,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad4)
    Numpad4 = 37,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad5)
    Numpad5 = 38,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad6)
    Numpad6 = 39,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad7)
    Numpad7 = 40,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad8)
    Numpad8 = 41,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad9)
    Numpad9 = 42,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Cancel)
    Cancel = 43,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Clear)
    Clear = 44,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Menu)
    Menu = 45,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Pause)
    Pause = 46,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Kana)
    Kana = 47,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Hangul)
    Hangul = 48,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Junja)
    Junja = 49,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Final)
    Final = 50,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Hanja)
    Hanja = 51,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Kanji)
    Kanji = 52,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Convert)
    Convert = 53,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Select)
    Select = 54,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Print)
    Print = 55,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Execute)
    Execute = 56,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Snapshot)
    Snapshot = 57,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Insert)
    Insert = 58,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Help)
    Help = 59,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Sleep)
    Sleep = 60,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Separator)
    Separator = 61,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Scroll)
    Scroll = 62,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.NumLock)
    NumLock = 63,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RWin)
    RWin = 64,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Apps)
    Apps = 65,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Multiply)
    Multiply = 66,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Add)
    Add = 67,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Subtract)
    Subtract = 68,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Decimal)
    Decimal = 69,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Divide)
    Divide = 70,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Equals)
    Equals = 71,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.NumpadEnter)
    NumpadEnter = 72,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RShift)
    RShift = 73,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RControl)
    RControl = 74,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RAlt)
    RAlt = 75,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.VolumeMute)
    VolumeMute = 76,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.VolumeUp)
    VolumeUp = 77,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.VolumeDown)
    VolumeDown = 78,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Power)
    Power = 79,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.CtrlAltDel)
    CtrlAltDel = 100,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.LockScreen)
    LockScreen = 101,
}

impl ::protobuf::Enum for ControlKey {
    const NAME: &'static str = "ControlKey";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ControlKey> {
        match value {
            0 => ::std::option::Option::Some(ControlKey::Unknown),
            1 => ::std::option::Option::Some(ControlKey::Alt),
            2 => ::std::option::Option::Some(ControlKey::Backspace),
            3 => ::std::option::Option::Some(ControlKey::CapsLock),
            4 => ::std::option::Option::Some(ControlKey::Control),
            5 => ::std::option::Option::Some(ControlKey::Delete),
            6 => ::std::option::Option::Some(ControlKey::DownArrow),
            7 => ::std::option::Option::Some(ControlKey::End),
            8 => ::std::option::Option::Some(ControlKey::Escape),
            9 => ::std::option::Option::Some(ControlKey::F1),
            10 => ::std::option::Option::Some(ControlKey::F10),
            11 => ::std::option::Option::Some(ControlKey::F11),
            12 => ::std::option::Option::Some(ControlKey::F12),
            13 => ::std::option::Option::Some(ControlKey::F2),
            14 => ::std::option::Option::Some(ControlKey::F3),
            15 => ::std::option::Option::Some(ControlKey::F4),
            16 => ::std::option::Option::Some(ControlKey::F5),
            17 => ::std::option::Option::Some(ControlKey::F6),
            18 => ::std::option::Option::Some(ControlKey::F7),
            19 => ::std::option::Option::Some(ControlKey::F8),
            20 => ::std::option::Option::Some(ControlKey::F9),
            21 => ::std::option::Option::Some(ControlKey::Home),
            22 => ::std::option::Option::Some(ControlKey::LeftArrow),
            23 => ::std::option::Option::Some(ControlKey::Meta),
            24 => ::std::option::Option::Some(ControlKey::Option),
            25 => ::std::option::Option::Some(ControlKey::PageDown),
            26 => ::std::option::Option::Some(ControlKey::PageUp),
            27 => ::std::option::Option::Some(ControlKey::Return),
            28 => ::std::option::Option::Some(ControlKey::RightArrow),
            29 => ::std::option::Option::Some(ControlKey::Shift),
            30 => ::std::option::Option::Some(ControlKey::Space),
            31 => ::std::option::Option::Some(ControlKey::Tab),
            32 => ::std::option::Option::Some(ControlKey::UpArrow),
            33 => ::std::option::Option::Some(ControlKey::Numpad0),
            34 => ::std::option::Option::Some(ControlKey::Numpad1),
            35 => ::std::option::Option::Some(ControlKey::Numpad2),
            36 => ::std::option::Option::Some(ControlKey::Numpad3),
            37 => ::std::option::Option::Some(ControlKey::Numpad4),
            38 => ::std::option::Option::Some(ControlKey::Numpad5),
            39 => ::std::option::Option::Some(ControlKey::Numpad6),
            40 => ::std::option::Option::Some(ControlKey::Numpad7),
            41 => ::std::option::Option::Some(ControlKey::Numpad8),
            42 => ::std::option::Option::Some(ControlKey::Numpad9),
            43 => ::std::option::Option::Some(ControlKey::Cancel),
            44 => ::std::option::Option::Some(ControlKey::Clear),
            45 => ::std::option::Option::Some(ControlKey::Menu),
            46 => ::std::option::Option::Some(ControlKey::Pause),
            47 => ::std::option::Option::Some(ControlKey::Kana),
            48 => ::std::option::Option::Some(ControlKey::Hangul),
            49 => ::std::option::Option::Some(ControlKey::Junja),
            50 => ::std::option::Option::Some(ControlKey::Final),
            51 => ::std::option::Option::Some(ControlKey::Hanja),
            52 => ::std::option::Option::Some(ControlKey::Kanji),
            53 => ::std::option::Option::Some(ControlKey::Convert),
            54 => ::std::option::Option::Some(ControlKey::Select),
            55 => ::std::option::Option::Some(ControlKey::Print),
            56 => ::std::option::Option::Some(ControlKey::Execute),
            57 => ::std::option::Option::Some(ControlKey::Snapshot),
            58 => ::std::option::Option::Some(ControlKey::Insert),
            59 => ::std::option::Option::Some(ControlKey::Help),
            60 => ::std::option::Option::Some(ControlKey::Sleep),
            61 => ::std::option::Option::Some(ControlKey::Separator),
            62 => ::std::option::Option::Some(ControlKey::Scroll),
            63 => ::std::option::Option::Some(ControlKey::NumLock),
            64 => ::std::option::Option::Some(ControlKey::RWin),
            65 => ::std::option::Option::Some(ControlKey::Apps),
            66 => ::std::option::Option::Some(ControlKey::Multiply),
            67 => ::std::option::Option::Some(ControlKey::Add),
            68 => ::std::option::Option::Some(ControlKey::Subtract),
            69 => ::std::option::Option::Some(ControlKey::Decimal),
            70 => ::std::option::Option::Some(ControlKey::Divide),
            71 => ::std::option::Option::Some(ControlKey::Equals),
            72 => ::std::option::Option::Some(ControlKey::NumpadEnter),
            73 => ::std::option::Option::Some(ControlKey::RShift),
            74 => ::std::option::Option::Some(ControlKey::RControl),
            75 => ::std::option::Option::Some(ControlKey::RAlt),
            76 => ::std::option::Option::Some(ControlKey::VolumeMute),
            77 => ::std::option::Option::Some(ControlKey::VolumeUp),
            78 => ::std::option::Option::Some(ControlKey::VolumeDown),
            79 => ::std::option::Option::Some(ControlKey::Power),
            100 => ::std::option::Option::Some(ControlKey::CtrlAltDel),
            101 => ::std::option::Option::Some(ControlKey::LockScreen),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ControlKey> {
        match str {
            "Unknown" => ::std::option::Option::Some(ControlKey::Unknown),
            "Alt" => ::std::option::Option::Some(ControlKey::Alt),
            "Backspace" => ::std::option::Option::Some(ControlKey::Backspace),
            "CapsLock" => ::std::option::Option::Some(ControlKey::CapsLock),
            "Control" => ::std::option::Option::Some(ControlKey::Control),
            "Delete" => ::std::option::Option::Some(ControlKey::Delete),
            "DownArrow" => ::std::option::Option::Some(ControlKey::DownArrow),
            "End" => ::std::option::Option::Some(ControlKey::End),
            "Escape" => ::std::option::Option::Some(ControlKey::Escape),
            "F1" => ::std::option::Option::Some(ControlKey::F1),
            "F10" => ::std::option::Option::Some(ControlKey::F10),
            "F11" => ::std::option::Option::Some(ControlKey::F11),
            "F12" => ::std::option::Option::Some(ControlKey::F12),
            "F2" => ::std::option::Option::Some(ControlKey::F2),
            "F3" => ::std::option::Option::Some(ControlKey::F3),
            "F4" => ::std::option::Option::Some(ControlKey::F4),
            "F5" => ::std::option::Option::Some(ControlKey::F5),
            "F6" => ::std::option::Option::Some(ControlKey::F6),
            "F7" => ::std::option::Option::Some(ControlKey::F7),
            "F8" => ::std::option::Option::Some(ControlKey::F8),
            "F9" => ::std::option::Option::Some(ControlKey::F9),
            "Home" => ::std::option::Option::Some(ControlKey::Home),
            "LeftArrow" => ::std::option::Option::Some(ControlKey::LeftArrow),
            "Meta" => ::std::option::Option::Some(ControlKey::Meta),
            "Option" => ::std::option::Option::Some(ControlKey::Option),
            "PageDown" => ::std::option::Option::Some(ControlKey::PageDown),
            "PageUp" => ::std::option::Option::Some(ControlKey::PageUp),
            "Return" => ::std::option::Option::Some(ControlKey::Return),
            "RightArrow" => ::std::option::Option::Some(ControlKey::RightArrow),
            "Shift" => ::std::option::Option::Some(ControlKey::Shift),
            "Space" => ::std::option::Option::Some(ControlKey::Space),
            "Tab" => ::std::option::Option::Some(ControlKey::Tab),
            "UpArrow" => ::std::option::Option::Some(ControlKey::UpArrow),
            "Numpad0" => ::std::option::Option::Some(ControlKey::Numpad0),
            "Numpad1" => ::std::option::Option::Some(ControlKey::Numpad1),
            "Numpad2" => ::std::option::Option::Some(ControlKey::Numpad2),
            "Numpad3" => ::std::option::Option::Some(ControlKey::Numpad3),
            "Numpad4" => ::std::option::Option::Some(ControlKey::Numpad4),
            "Numpad5" => ::std::option::Option::Some(ControlKey::Numpad5),
            "Numpad6" => ::std::option::Option::Some(ControlKey::Numpad6),
            "Numpad7" => ::std::option::Option::Some(ControlKey::Numpad7),
            "Numpad8" => ::std::option::Option::Some(ControlKey::Numpad8),
            "Numpad9" => ::std::option::Option::Some(ControlKey::Numpad9),
            "Cancel" => ::std::option::Option::Some(ControlKey::Cancel),
            "Clear" => ::std::option::Option::Some(ControlKey::Clear),
            "Menu" => ::std::option::Option::Some(ControlKey::Menu),
            "Pause" => ::std::option::Option::Some(ControlKey::Pause),
            "Kana" => ::std::option::Option::Some(ControlKey::Kana),
            "Hangul" => ::std::option::Option::Some(ControlKey::Hangul),
            "Junja" => ::std::option::Option::Some(ControlKey::Junja),
            "Final" => ::std::option::Option::Some(ControlKey::Final),
            "Hanja" => ::std::option::Option::Some(ControlKey::Hanja),
            "Kanji" => ::std::option::Option::Some(ControlKey::Kanji),
            "Convert" => ::std::option::Option::Some(ControlKey::Convert),
            "Select" => ::std::option::Option::Some(ControlKey::Select),
            "Print" => ::std::option::Option::Some(ControlKey::Print),
            "Execute" => ::std::option::Option::Some(ControlKey::Execute),
            "Snapshot" => ::std::option::Option::Some(ControlKey::Snapshot),
            "Insert" => ::std::option::Option::Some(ControlKey::Insert),
            "Help" => ::std::option::Option::Some(ControlKey::Help),
            "Sleep" => ::std::option::Option::Some(ControlKey::Sleep),
            "Separator" => ::std::option::Option::Some(ControlKey::Separator),
            "Scroll" => ::std::option::Option::Some(ControlKey::Scroll),
            "NumLock" => ::std::option::Option::Some(ControlKey::NumLock),
            "RWin" => ::std::option::Option::Some(ControlKey::RWin),
            "Apps" => ::std::option::Option::Some(ControlKey::Apps),
            "Multiply" => ::std::option::Option::Some(ControlKey::Multiply),
            "Add" => ::std::option::Option::Some(ControlKey::Add),
            "Subtract" => ::std::option::Option::Some(ControlKey::Subtract),
            "Decimal" => ::std::option::Option::Some(ControlKey::Decimal),
            "Divide" => ::std::option::Option::Some(ControlKey::Divide),
            "Equals" => ::std::option::Option::Some(ControlKey::Equals),
            "NumpadEnter" => ::std::option::Option::Some(ControlKey::NumpadEnter),
            "RShift" => ::std::option::Option::Some(ControlKey::RShift),
            "RControl" => ::std::option::Option::Some(ControlKey::RControl),
            "RAlt" => ::std::option::Option::Some(ControlKey::RAlt),
            "VolumeMute" => ::std::option::Option::Some(ControlKey::VolumeMute),
            "VolumeUp" => ::std::option::Option::Some(ControlKey::VolumeUp),
            "VolumeDown" => ::std::option::Option::Some(ControlKey::VolumeDown),
            "Power" => ::std::option::Option::Some(ControlKey::Power),
            "CtrlAltDel" => ::std::option::Option::Some(ControlKey::CtrlAltDel),
            "LockScreen" => ::std::option::Option::Some(ControlKey::LockScreen),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ControlKey] = &[
        ControlKey::Unknown,
        ControlKey::Alt,
        ControlKey::Backspace,
        ControlKey::CapsLock,
        ControlKey::Control,
        ControlKey::Delete,
        ControlKey::DownArrow,
        ControlKey::End,
        ControlKey::Escape,
        ControlKey::F1,
        ControlKey::F10,
        ControlKey::F11,
        ControlKey::F12,
        ControlKey::F2,
        ControlKey::F3,
        ControlKey::F4,
        ControlKey::F5,
        ControlKey::F6,
        ControlKey::F7,
        ControlKey::F8,
        ControlKey::F9,
        ControlKey::Home,
        ControlKey::LeftArrow,
        ControlKey::Meta,
        ControlKey::Option,
        ControlKey::PageDown,
        ControlKey::PageUp,
        ControlKey::Return,
        ControlKey::RightArrow,
        ControlKey::Shift,
        ControlKey::Space,
        ControlKey::Tab,
        ControlKey::UpArrow,
        ControlKey::Numpad0,
        ControlKey::Numpad1,
        ControlKey::Numpad2,
        ControlKey::Numpad3,
        ControlKey::Numpad4,
        ControlKey::Numpad5,
        ControlKey::Numpad6,
        ControlKey::Numpad7,
        ControlKey::Numpad8,
        ControlKey::Numpad9,
        ControlKey::Cancel,
        ControlKey::Clear,
        ControlKey::Menu,
        ControlKey::Pause,
        ControlKey::Kana,
        ControlKey::Hangul,
        ControlKey::Junja,
        ControlKey::Final,
        ControlKey::Hanja,
        ControlKey::Kanji,
        ControlKey::Convert,
        ControlKey::Select,
        ControlKey::Print,
        ControlKey::Execute,
        ControlKey::Snapshot,
        ControlKey::Insert,
        ControlKey::Help,
        ControlKey::Sleep,
        ControlKey::Separator,
        ControlKey::Scroll,
        ControlKey::NumLock,
        ControlKey::RWin,
        ControlKey::Apps,
        ControlKey::Multiply,
        ControlKey::Add,
        ControlKey::Subtract,
        ControlKey::Decimal,
        ControlKey::Divide,
        ControlKey::Equals,
        ControlKey::NumpadEnter,
        ControlKey::RShift,
        ControlKey::RControl,
        ControlKey::RAlt,
        ControlKey::VolumeMute,
        ControlKey::VolumeUp,
        ControlKey::VolumeDown,
        ControlKey::Power,
        ControlKey::CtrlAltDel,
        ControlKey::LockScreen,
    ];
}

impl ::protobuf::EnumFull for ControlKey {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ControlKey").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ControlKey::Unknown => 0,
            ControlKey::Alt => 1,
            ControlKey::Backspace => 2,
            ControlKey::CapsLock => 3,
            ControlKey::Control => 4,
            ControlKey::Delete => 5,
            ControlKey::DownArrow => 6,
            ControlKey::End => 7,
            ControlKey::Escape => 8,
            ControlKey::F1 => 9,
            ControlKey::F10 => 10,
            ControlKey::F11 => 11,
            ControlKey::F12 => 12,
            ControlKey::F2 => 13,
            ControlKey::F3 => 14,
            ControlKey::F4 => 15,
            ControlKey::F5 => 16,
            ControlKey::F6 => 17,
            ControlKey::F7 => 18,
            ControlKey::F8 => 19,
            ControlKey::F9 => 20,
            ControlKey::Home => 21,
            ControlKey::LeftArrow => 22,
            ControlKey::Meta => 23,
            ControlKey::Option => 24,
            ControlKey::PageDown => 25,
            ControlKey::PageUp => 26,
            ControlKey::Return => 27,
            ControlKey::RightArrow => 28,
            ControlKey::Shift => 29,
            ControlKey::Space => 30,
            ControlKey::Tab => 31,
            ControlKey::UpArrow => 32,
            ControlKey::Numpad0 => 33,
            ControlKey::Numpad1 => 34,
            ControlKey::Numpad2 => 35,
            ControlKey::Numpad3 => 36,
            ControlKey::Numpad4 => 37,
            ControlKey::Numpad5 => 38,
            ControlKey::Numpad6 => 39,
            ControlKey::Numpad7 => 40,
            ControlKey::Numpad8 => 41,
            ControlKey::Numpad9 => 42,
            ControlKey::Cancel => 43,
            ControlKey::Clear => 44,
            ControlKey::Menu => 45,
            ControlKey::Pause => 46,
            ControlKey::Kana => 47,
            ControlKey::Hangul => 48,
            ControlKey::Junja => 49,
            ControlKey::Final => 50,
            ControlKey::Hanja => 51,
            ControlKey::Kanji => 52,
            ControlKey::Convert => 53,
            ControlKey::Select => 54,
            ControlKey::Print => 55,
            ControlKey::Execute => 56,
            ControlKey::Snapshot => 57,
            ControlKey::Insert => 58,
            ControlKey::Help => 59,
            ControlKey::Sleep => 60,
            ControlKey::Separator => 61,
            ControlKey::Scroll => 62,
            ControlKey::NumLock => 63,
            ControlKey::RWin => 64,
            ControlKey::Apps => 65,
            ControlKey::Multiply => 66,
            ControlKey::Add => 67,
            ControlKey::Subtract => 68,
            ControlKey::Decimal => 69,
            ControlKey::Divide => 70,
            ControlKey::Equals => 71,
            ControlKey::NumpadEnter => 72,
            ControlKey::RShift => 73,
            ControlKey::RControl => 74,
            ControlKey::RAlt => 75,
            ControlKey::VolumeMute => 76,
            ControlKey::VolumeUp => 77,
            ControlKey::VolumeDown => 78,
            ControlKey::Power => 79,
            ControlKey::CtrlAltDel => 80,
            ControlKey::LockScreen => 81,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ControlKey {
    fn default() -> Self {
        ControlKey::Unknown
    }
}

impl ControlKey {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlKey>("ControlKey")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.FileType)
pub enum FileType {
    // @@protoc_insertion_point(enum_value:hbb.FileType.Dir)
    Dir = 0,
    // @@protoc_insertion_point(enum_value:hbb.FileType.DirLink)
    DirLink = 2,
    // @@protoc_insertion_point(enum_value:hbb.FileType.DirDrive)
    DirDrive = 3,
    // @@protoc_insertion_point(enum_value:hbb.FileType.File)
    File = 4,
    // @@protoc_insertion_point(enum_value:hbb.FileType.FileLink)
    FileLink = 5,
}

impl ::protobuf::Enum for FileType {
    const NAME: &'static str = "FileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileType> {
        match value {
            0 => ::std::option::Option::Some(FileType::Dir),
            2 => ::std::option::Option::Some(FileType::DirLink),
            3 => ::std::option::Option::Some(FileType::DirDrive),
            4 => ::std::option::Option::Some(FileType::File),
            5 => ::std::option::Option::Some(FileType::FileLink),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FileType> {
        match str {
            "Dir" => ::std::option::Option::Some(FileType::Dir),
            "DirLink" => ::std::option::Option::Some(FileType::DirLink),
            "DirDrive" => ::std::option::Option::Some(FileType::DirDrive),
            "File" => ::std::option::Option::Some(FileType::File),
            "FileLink" => ::std::option::Option::Some(FileType::FileLink),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileType] = &[
        FileType::Dir,
        FileType::DirLink,
        FileType::DirDrive,
        FileType::File,
        FileType::FileLink,
    ];
}

impl ::protobuf::EnumFull for FileType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FileType::Dir => 0,
            FileType::DirLink => 1,
            FileType::DirDrive => 2,
            FileType::File => 3,
            FileType::FileLink => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FileType {
    fn default() -> Self {
        FileType::Dir
    }
}

impl FileType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileType>("FileType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.ImageQuality)
pub enum ImageQuality {
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.NotSet)
    NotSet = 0,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Low)
    Low = 2,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Balanced)
    Balanced = 3,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Best)
    Best = 4,
}

impl ::protobuf::Enum for ImageQuality {
    const NAME: &'static str = "ImageQuality";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageQuality> {
        match value {
            0 => ::std::option::Option::Some(ImageQuality::NotSet),
            2 => ::std::option::Option::Some(ImageQuality::Low),
            3 => ::std::option::Option::Some(ImageQuality::Balanced),
            4 => ::std::option::Option::Some(ImageQuality::Best),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImageQuality> {
        match str {
            "NotSet" => ::std::option::Option::Some(ImageQuality::NotSet),
            "Low" => ::std::option::Option::Some(ImageQuality::Low),
            "Balanced" => ::std::option::Option::Some(ImageQuality::Balanced),
            "Best" => ::std::option::Option::Some(ImageQuality::Best),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImageQuality] = &[
        ImageQuality::NotSet,
        ImageQuality::Low,
        ImageQuality::Balanced,
        ImageQuality::Best,
    ];
}

impl ::protobuf::EnumFull for ImageQuality {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ImageQuality").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ImageQuality::NotSet => 0,
            ImageQuality::Low => 1,
            ImageQuality::Balanced => 2,
            ImageQuality::Best => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ImageQuality {
    fn default() -> Self {
        ImageQuality::NotSet
    }
}

impl ImageQuality {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ImageQuality>("ImageQuality")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x12\x03hbb\"K\n\x11EncodedVideoFrame\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data\x12\x10\n\x03key\x18\x02\x20\x01(\x08R\
    \x03key\x12\x10\n\x03pts\x18\x03\x20\x01(\x03R\x03pts\"D\n\x12EncodedVid\
    eoFrames\x12.\n\x06frames\x18\x01\x20\x03(\x0b2\x16.hbb.EncodedVideoFram\
    eR\x06frames\"!\n\x03RGB\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08\
    compress\"9\n\x03YUV\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08comp\
    ress\x12\x16\n\x06stride\x18\x02\x20\x01(\x05R\x06stride\"\xda\x02\n\nVi\
    deoFrame\x12-\n\x04vp9s\x18\x06\x20\x01(\x0b2\x17.hbb.EncodedVideoFrames\
    H\0R\x04vp9s\x12\x1c\n\x03rgb\x18\x07\x20\x01(\x0b2\x08.hbb.RGBH\0R\x03r\
    gb\x12\x1c\n\x03yuv\x18\x08\x20\x01(\x0b2\x08.hbb.YUVH\0R\x03yuv\x12/\n\
    \x05h264s\x18\n\x20\x01(\x0b2\x17.hbb.EncodedVideoFramesH\0R\x05h264s\
    \x12/\n\x05h265s\x18\x0b\x20\x01(\x0b2\x17.hbb.EncodedVideoFramesH\0R\
    \x05h265s\x12-\n\x04vp8s\x18\x0c\x20\x01(\x0b2\x17.hbb.EncodedVideoFrame\
    sH\0R\x04vp8s\x12-\n\x04av1s\x18\r\x20\x01(\x0b2\x17.hbb.EncodedVideoFra\
    mesH\0R\x04av1s\x12\x18\n\x07display\x18\x0e\x20\x01(\x05R\x07displayB\
    \x07\n\x05union\"&\n\x04IdPk\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x0e\n\x02pk\x18\x02\x20\x01(\x0cR\x02pk\"\x84\x02\n\x0bDisplayInfo\
    \x12\x0c\n\x01x\x18\x01\x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\x02\x20\
    \x01(\x11R\x01y\x12\x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\
    \x16\n\x06height\x18\x04\x20\x01(\x05R\x06height\x12\x12\n\x04name\x18\
    \x05\x20\x01(\tR\x04name\x12\x16\n\x06online\x18\x06\x20\x01(\x08R\x06on\
    line\x12'\n\x0fcursor_embedded\x18\x07\x20\x01(\x08R\x0ecursorEmbedded\
    \x12@\n\x13original_resolution\x18\x08\x20\x01(\x0b2\x0f.hbb.ResolutionR\
    \x12originalResolution\x12\x14\n\x05scale\x18\t\x20\x01(\x01R\x05scale\"\
    5\n\x0bPortForward\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\
    \n\x04port\x18\x02\x20\x01(\x05R\x04port\"A\n\x0cFileTransfer\x12\x10\n\
    \x03dir\x18\x01\x20\x01(\tR\x03dir\x12\x1f\n\x0bshow_hidden\x18\x02\x20\
    \x01(\x08R\nshowHidden\"A\n\x07OSLogin\x12\x1a\n\x08username\x18\x01\x20\
    \x01(\tR\x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08passwo\
    rd\"\xaa\x03\n\x0cLoginRequest\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\
    \x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\x0cR\x08password\x12\
    \x13\n\x05my_id\x18\x04\x20\x01(\tR\x04myId\x12\x17\n\x07my_name\x18\x05\
    \x20\x01(\tR\x06myName\x12*\n\x06option\x18\x06\x20\x01(\x0b2\x12.hbb.Op\
    tionMessageR\x06option\x128\n\rfile_transfer\x18\x07\x20\x01(\x0b2\x11.h\
    bb.FileTransferH\0R\x0cfileTransfer\x125\n\x0cport_forward\x18\x08\x20\
    \x01(\x0b2\x10.hbb.PortForwardH\0R\x0bportForward\x12,\n\x12video_ack_re\
    quired\x18\t\x20\x01(\x08R\x10videoAckRequired\x12\x1d\n\nsession_id\x18\
    \n\x20\x01(\x04R\tsessionId\x12\x18\n\x07version\x18\x0b\x20\x01(\tR\x07\
    version\x12'\n\x08os_login\x18\x0c\x20\x01(\x0b2\x0c.hbb.OSLoginR\x07osL\
    oginB\x07\n\x05union\"\x1d\n\x07Auth2FA\x12\x12\n\x04code\x18\x01\x20\
    \x01(\tR\x04code\"!\n\x0bChatMessage\x12\x12\n\x04text\x18\x01\x20\x01(\
    \tR\x04text\"-\n\x08Features\x12!\n\x0cprivacy_mode\x18\x01\x20\x01(\x08\
    R\x0bprivacyMode\"l\n\x0cCodecAbility\x12\x10\n\x03vp8\x18\x01\x20\x01(\
    \x08R\x03vp8\x12\x10\n\x03vp9\x18\x02\x20\x01(\x08R\x03vp9\x12\x10\n\x03\
    av1\x18\x03\x20\x01(\x08R\x03av1\x12\x12\n\x04h264\x18\x04\x20\x01(\x08R\
    \x04h264\x12\x12\n\x04h265\x18\x05\x20\x01(\x08R\x04h265\"\x86\x01\n\x11\
    SupportedEncoding\x12\x12\n\x04h264\x18\x01\x20\x01(\x08R\x04h264\x12\
    \x12\n\x04h265\x18\x02\x20\x01(\x08R\x04h265\x12\x10\n\x03vp8\x18\x03\
    \x20\x01(\x08R\x03vp8\x12\x10\n\x03av1\x18\x04\x20\x01(\x08R\x03av1\x12%\
    \n\x04i444\x18\x05\x20\x01(\x0b2\x11.hbb.CodecAbilityR\x04i444\"\xfc\x03\
    \n\x08PeerInfo\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\
    \x1a\n\x08hostname\x18\x02\x20\x01(\tR\x08hostname\x12\x1a\n\x08platform\
    \x18\x03\x20\x01(\tR\x08platform\x12,\n\x08displays\x18\x04\x20\x03(\x0b\
    2\x10.hbb.DisplayInfoR\x08displays\x12'\n\x0fcurrent_display\x18\x05\x20\
    \x01(\x05R\x0ecurrentDisplay\x12\x1f\n\x0bsas_enabled\x18\x06\x20\x01(\
    \x08R\nsasEnabled\x12\x18\n\x07version\x18\x07\x20\x01(\tR\x07version\
    \x12)\n\x08features\x18\t\x20\x01(\x0b2\r.hbb.FeaturesR\x08features\x122\
    \n\x08encoding\x18\n\x20\x01(\x0b2\x16.hbb.SupportedEncodingR\x08encodin\
    g\x12;\n\x0bresolutions\x18\x0b\x20\x01(\x0b2\x19.hbb.SupportedResolutio\
    nsR\x0bresolutions\x12-\n\x12platform_additions\x18\x0c\x20\x01(\tR\x11p\
    latformAdditions\x12?\n\x10windows_sessions\x18\r\x20\x01(\x0b2\x14.hbb.\
    WindowsSessionsR\x0fwindowsSessions\"6\n\x0eWindowsSession\x12\x10\n\x03\
    sid\x18\x01\x20\x01(\rR\x03sid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04\
    name\"^\n\rLoginResponse\x12\x16\n\x05error\x18\x01\x20\x01(\tH\0R\x05er\
    ror\x12,\n\tpeer_info\x18\x02\x20\x01(\x0b2\r.hbb.PeerInfoH\0R\x08peerIn\
    foB\x07\n\x05union\"(\n\x10TouchScaleUpdate\x12\x14\n\x05scale\x18\x01\
    \x20\x01(\x05R\x05scale\"+\n\rTouchPanStart\x12\x0c\n\x01x\x18\x01\x20\
    \x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\",\n\x0eTouchP\
    anUpdate\x12\x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x05R\x01y\")\n\x0bTouchPanEnd\x12\x0c\n\x01x\x18\x01\x20\
    \x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\"\xe7\x01\n\nT\
    ouchEvent\x12:\n\x0cscale_update\x18\x01\x20\x01(\x0b2\x15.hbb.TouchScal\
    eUpdateH\0R\x0bscaleUpdate\x121\n\tpan_start\x18\x02\x20\x01(\x0b2\x12.h\
    bb.TouchPanStartH\0R\x08panStart\x124\n\npan_update\x18\x03\x20\x01(\x0b\
    2\x13.hbb.TouchPanUpdateH\0R\tpanUpdate\x12+\n\x07pan_end\x18\x04\x20\
    \x01(\x0b2\x10.hbb.TouchPanEndH\0R\x06panEndB\x07\n\x05union\"\x80\x01\n\
    \x12PointerDeviceEvent\x122\n\x0btouch_event\x18\x01\x20\x01(\x0b2\x0f.h\
    bb.TouchEventH\0R\ntouchEvent\x12-\n\tmodifiers\x18\x02\x20\x03(\x0e2\
    \x0f.hbb.ControlKeyR\tmodifiersB\x07\n\x05union\"k\n\nMouseEvent\x12\x12\
    \n\x04mask\x18\x01\x20\x01(\x05R\x04mask\x12\x0c\n\x01x\x18\x02\x20\x01(\
    \x11R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x11R\x01y\x12-\n\tmodifiers\
    \x18\x04\x20\x03(\x0e2\x0f.hbb.ControlKeyR\tmodifiers\"\xb4\x02\n\x08Key\
    Event\x12\x12\n\x04down\x18\x01\x20\x01(\x08R\x04down\x12\x14\n\x05press\
    \x18\x02\x20\x01(\x08R\x05press\x122\n\x0bcontrol_key\x18\x03\x20\x01(\
    \x0e2\x0f.hbb.ControlKeyH\0R\ncontrolKey\x12\x12\n\x03chr\x18\x04\x20\
    \x01(\rH\0R\x03chr\x12\x1a\n\x07unicode\x18\x05\x20\x01(\rH\0R\x07unicod\
    e\x12\x12\n\x03seq\x18\x06\x20\x01(\tH\0R\x03seq\x12'\n\x0ewin2win_hotke\
    y\x18\x07\x20\x01(\rH\0R\rwin2winHotkey\x12-\n\tmodifiers\x18\x08\x20\
    \x03(\x0e2\x0f.hbb.ControlKeyR\tmodifiers\x12%\n\x04mode\x18\t\x20\x01(\
    \x0e2\x11.hbb.KeyboardModeR\x04modeB\x07\n\x05union\"\x8a\x01\n\nCursorD\
    ata\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x12\n\x04hotx\x18\
    \x02\x20\x01(\x11R\x04hotx\x12\x12\n\x04hoty\x18\x03\x20\x01(\x11R\x04ho\
    ty\x12\x14\n\x05width\x18\x04\x20\x01(\x05R\x05width\x12\x16\n\x06height\
    \x18\x05\x20\x01(\x05R\x06height\x12\x16\n\x06colors\x18\x06\x20\x01(\
    \x0cR\x06colors\",\n\x0eCursorPosition\x12\x0c\n\x01x\x18\x01\x20\x01(\
    \x11R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x11R\x01y\"8\n\x04Hash\x12\
    \x12\n\x04salt\x18\x01\x20\x01(\tR\x04salt\x12\x1c\n\tchallenge\x18\x02\
    \x20\x01(\tR\tchallenge\"o\n\tClipboard\x12\x1a\n\x08compress\x18\x01\
    \x20\x01(\x08R\x08compress\x12\x18\n\x07content\x18\x02\x20\x01(\x0cR\
    \x07content\x12\x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\
    \x06height\x18\x04\x20\x01(\x05R\x06height\"\xa3\x01\n\tFileEntry\x12,\n\
    \nentry_type\x18\x01\x20\x01(\x0e2\r.hbb.FileTypeR\tentryType\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x1b\n\tis_hidden\x18\x03\x20\
    \x01(\x08R\x08isHidden\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\
    \x12#\n\rmodified_time\x18\x05\x20\x01(\x04R\x0cmodifiedTime\"]\n\rFileD\
    irectory\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04path\
    \x18\x02\x20\x01(\tR\x04path\x12(\n\x07entries\x18\x03\x20\x03(\x0b2\x0e\
    .hbb.FileEntryR\x07entries\"D\n\x07ReadDir\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12%\n\x0einclude_hidden\x18\x02\x20\x01(\x08R\rinclude\
    Hidden\"Y\n\x0cReadAllFiles\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12%\n\x0einclude_hidden\
    \x18\x03\x20\x01(\x08R\rincludeHidden\"\xfb\x03\n\nFileAction\x12)\n\x08\
    read_dir\x18\x01\x20\x01(\x0b2\x0c.hbb.ReadDirH\0R\x07readDir\x122\n\x04\
    send\x18\x02\x20\x01(\x0b2\x1c.hbb.FileTransferSendRequestH\0R\x04send\
    \x12;\n\x07receive\x18\x03\x20\x01(\x0b2\x1f.hbb.FileTransferReceiveRequ\
    estH\0R\x07receive\x12,\n\x06create\x18\x04\x20\x01(\x0b2\x12.hbb.FileDi\
    rCreateH\0R\x06create\x123\n\nremove_dir\x18\x05\x20\x01(\x0b2\x12.hbb.F\
    ileRemoveDirH\0R\tremoveDir\x126\n\x0bremove_file\x18\x06\x20\x01(\x0b2\
    \x13.hbb.FileRemoveFileH\0R\nremoveFile\x120\n\tall_files\x18\x07\x20\
    \x01(\x0b2\x11.hbb.ReadAllFilesH\0R\x08allFiles\x121\n\x06cancel\x18\x08\
    \x20\x01(\x0b2\x17.hbb.FileTransferCancelH\0R\x06cancel\x12H\n\x0csend_c\
    onfirm\x18\t\x20\x01(\x0b2#.hbb.FileTransferSendConfirmRequestH\0R\x0bse\
    ndConfirmB\x07\n\x05union\"$\n\x12FileTransferCancel\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\"\xff\x01\n\x0cFileResponse\x12&\n\x03dir\x18\
    \x01\x20\x01(\x0b2\x12.hbb.FileDirectoryH\0R\x03dir\x12.\n\x05block\x18\
    \x02\x20\x01(\x0b2\x16.hbb.FileTransferBlockH\0R\x05block\x12.\n\x05erro\
    r\x18\x03\x20\x01(\x0b2\x16.hbb.FileTransferErrorH\0R\x05error\x12+\n\
    \x04done\x18\x04\x20\x01(\x0b2\x15.hbb.FileTransferDoneH\0R\x04done\x121\
    \n\x06digest\x18\x05\x20\x01(\x0b2\x17.hbb.FileTransferDigestH\0R\x06dig\
    estB\x07\n\x05union\"\xc1\x01\n\x12FileTransferDigest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\x18\x02\x20\x01(\x11R\
    \x07fileNum\x12#\n\rlast_modified\x18\x03\x20\x01(\x04R\x0clastModified\
    \x12\x1b\n\tfile_size\x18\x04\x20\x01(\x04R\x08fileSize\x12\x1b\n\tis_up\
    load\x18\x05\x20\x01(\x08R\x08isUpload\x12!\n\x0cis_identical\x18\x06\
    \x20\x01(\x08R\x0bisIdentical\"\x89\x01\n\x11FileTransferBlock\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\x18\x02\x20\x01\
    (\x11R\x07fileNum\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\x12\
    \x1e\n\ncompressed\x18\x04\x20\x01(\x08R\ncompressed\x12\x15\n\x06blk_id\
    \x18\x05\x20\x01(\rR\x05blkId\"T\n\x11FileTransferError\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05e\
    rror\x12\x19\n\x08file_num\x18\x03\x20\x01(\x11R\x07fileNum\"\x7f\n\x17F\
    ileTransferSendRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\
    \x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12%\n\x0einclude_hidden\x18\
    \x03\x20\x01(\x08R\rincludeHidden\x12\x19\n\x08file_num\x18\x04\x20\x01(\
    \x05R\x07fileNum\"\x8b\x01\n\x1eFileTransferSendConfirmRequest\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\x18\x02\x20\x01\
    (\x11R\x07fileNum\x12\x14\n\x04skip\x18\x03\x20\x01(\x08H\0R\x04skip\x12\
    \x1f\n\noffset_blk\x18\x04\x20\x01(\rH\0R\toffsetBlkB\x07\n\x05union\"=\
    \n\x10FileTransferDone\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\
    \x19\n\x08file_num\x18\x02\x20\x01(\x11R\x07fileNum\"\xa0\x01\n\x1aFileT\
    ransferReceiveRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\
    \x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12$\n\x05files\x18\x03\x20\
    \x03(\x0b2\x0e.hbb.FileEntryR\x05files\x12\x19\n\x08file_num\x18\x04\x20\
    \x01(\x05R\x07fileNum\x12\x1d\n\ntotal_size\x18\x05\x20\x01(\x04R\ttotal\
    Size\"Q\n\rFileRemoveDir\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\
    \x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x1c\n\trecursive\x18\x03\
    \x20\x01(\x08R\trecursive\"O\n\x0eFileRemoveFile\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x05R\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\
    \x19\n\x08file_num\x18\x03\x20\x01(\x11R\x07fileNum\"3\n\rFileDirCreate\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04path\x18\x02\
    \x20\x01(\tR\x04path\"\x15\n\x13CliprdrMonitorReady\"7\n\rCliprdrFormat\
    \x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\x02id\x12\x16\n\x06format\x18\x03\
    \x20\x01(\tR\x06format\"G\n\x17CliprdrServerFormatList\x12,\n\x07formats\
    \x18\x02\x20\x03(\x0b2\x12.hbb.CliprdrFormatR\x07formats\">\n\x1fCliprdr\
    ServerFormatListResponse\x12\x1b\n\tmsg_flags\x18\x02\x20\x01(\x05R\x08m\
    sgFlags\"P\n\x1eCliprdrServerFormatDataRequest\x12.\n\x13requested_forma\
    t_id\x18\x02\x20\x01(\x05R\x11requestedFormatId\"_\n\x1fCliprdrServerFor\
    matDataResponse\x12\x1b\n\tmsg_flags\x18\x02\x20\x01(\x05R\x08msgFlags\
    \x12\x1f\n\x0bformat_data\x18\x03\x20\x01(\x0cR\nformatData\"\xb1\x02\n\
    \x1aCliprdrFileContentsRequest\x12\x1b\n\tstream_id\x18\x02\x20\x01(\x05\
    R\x08streamId\x12\x1d\n\nlist_index\x18\x03\x20\x01(\x05R\tlistIndex\x12\
    \x19\n\x08dw_flags\x18\x04\x20\x01(\x05R\x07dwFlags\x12$\n\x0en_position\
    _low\x18\x05\x20\x01(\x05R\x0cnPositionLow\x12&\n\x0fn_position_high\x18\
    \x06\x20\x01(\x05R\rnPositionHigh\x12!\n\x0ccb_requested\x18\x07\x20\x01\
    (\x05R\x0bcbRequested\x12)\n\x11have_clip_data_id\x18\x08\x20\x01(\x08R\
    \x0ehaveClipDataId\x12\x20\n\x0cclip_data_id\x18\t\x20\x01(\x05R\nclipDa\
    taId\"~\n\x1bCliprdrFileContentsResponse\x12\x1b\n\tmsg_flags\x18\x03\
    \x20\x01(\x05R\x08msgFlags\x12\x1b\n\tstream_id\x18\x04\x20\x01(\x05R\
    \x08streamId\x12%\n\x0erequested_data\x18\x05\x20\x01(\x0cR\rrequestedDa\
    ta\"\xc1\x04\n\x07Cliprdr\x120\n\x05ready\x18\x01\x20\x01(\x0b2\x18.hbb.\
    CliprdrMonitorReadyH\0R\x05ready\x12?\n\x0bformat_list\x18\x02\x20\x01(\
    \x0b2\x1c.hbb.CliprdrServerFormatListH\0R\nformatList\x12X\n\x14format_l\
    ist_response\x18\x03\x20\x01(\x0b2$.hbb.CliprdrServerFormatListResponseH\
    \0R\x12formatListResponse\x12U\n\x13format_data_request\x18\x04\x20\x01(\
    \x0b2#.hbb.CliprdrServerFormatDataRequestH\0R\x11formatDataRequest\x12X\
    \n\x14format_data_response\x18\x05\x20\x01(\x0b2$.hbb.CliprdrServerForma\
    tDataResponseH\0R\x12formatDataResponse\x12U\n\x15file_contents_request\
    \x18\x06\x20\x01(\x0b2\x1f.hbb.CliprdrFileContentsRequestH\0R\x13fileCon\
    tentsRequest\x12X\n\x16file_contents_response\x18\x07\x20\x01(\x0b2\x20.\
    hbb.CliprdrFileContentsResponseH\0R\x14fileContentsResponseB\x07\n\x05un\
    ion\":\n\nResolution\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\
    \x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\"^\n\x11DisplayReso\
    lution\x12\x18\n\x07display\x18\x01\x20\x01(\x05R\x07display\x12/\n\nres\
    olution\x18\x02\x20\x01(\x0b2\x0f.hbb.ResolutionR\nresolution\"I\n\x14Su\
    pportedResolutions\x121\n\x0bresolutions\x18\x01\x20\x03(\x0b2\x0f.hbb.R\
    esolutionR\x0bresolutions\"\x9b\x02\n\rSwitchDisplay\x12\x18\n\x07displa\
    y\x18\x01\x20\x01(\x05R\x07display\x12\x0c\n\x01x\x18\x02\x20\x01(\x11R\
    \x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x11R\x01y\x12\x14\n\x05width\x18\
    \x04\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\x05R\
    \x06height\x12'\n\x0fcursor_embedded\x18\x06\x20\x01(\x08R\x0ecursorEmbe\
    dded\x12;\n\x0bresolutions\x18\x07\x20\x01(\x0b2\x19.hbb.SupportedResolu\
    tionsR\x0bresolutions\x12@\n\x13original_resolution\x18\x08\x20\x01(\x0b\
    2\x0f.hbb.ResolutionR\x12originalResolution\"G\n\x0fCaptureDisplays\x12\
    \x10\n\x03add\x18\x01\x20\x03(\x05R\x03add\x12\x10\n\x03sub\x18\x02\x20\
    \x03(\x05R\x03sub\x12\x10\n\x03set\x18\x03\x20\x03(\x05R\x03set\"@\n\x14\
    ToggleVirtualDisplay\x12\x18\n\x07display\x18\x01\x20\x01(\x05R\x07displ\
    ay\x12\x0e\n\x02on\x18\x02\x20\x01(\x08R\x02on\">\n\x11TogglePrivacyMode\
    \x12\x19\n\x08impl_key\x18\x01\x20\x01(\tR\x07implKey\x12\x0e\n\x02on\
    \x18\x02\x20\x01(\x08R\x02on\"\xd6\x01\n\x0ePermissionInfo\x12>\n\npermi\
    ssion\x18\x01\x20\x01(\x0e2\x1e.hbb.PermissionInfo.PermissionR\npermissi\
    on\x12\x18\n\x07enabled\x18\x02\x20\x01(\x08R\x07enabled\"j\n\nPermissio\
    n\x12\x0c\n\x08Keyboard\x10\0\x12\r\n\tClipboard\x10\x02\x12\t\n\x05Audi\
    o\x10\x03\x12\x08\n\x04File\x10\x04\x12\x0b\n\x07Restart\x10\x05\x12\r\n\
    \tRecording\x10\x06\x12\x0e\n\nBlockInput\x10\x07\"\x99\x03\n\x11Support\
    edDecoding\x12\x1f\n\x0bability_vp9\x18\x01\x20\x01(\x05R\nabilityVp9\
    \x12!\n\x0cability_h264\x18\x02\x20\x01(\x05R\x0babilityH264\x12!\n\x0ca\
    bility_h265\x18\x03\x20\x01(\x05R\x0babilityH265\x12:\n\x06prefer\x18\
    \x04\x20\x01(\x0e2\".hbb.SupportedDecoding.PreferCodecR\x06prefer\x12\
    \x1f\n\x0bability_vp8\x18\x05\x20\x01(\x05R\nabilityVp8\x12\x1f\n\x0babi\
    lity_av1\x18\x06\x20\x01(\x05R\nabilityAv1\x12%\n\x04i444\x18\x07\x20\
    \x01(\x0b2\x11.hbb.CodecAbilityR\x04i444\x120\n\rprefer_chroma\x18\x08\
    \x20\x01(\x0e2\x0b.hbb.ChromaR\x0cpreferChroma\"F\n\x0bPreferCodec\x12\
    \x08\n\x04Auto\x10\0\x12\x07\n\x03VP9\x10\x01\x12\x08\n\x04H264\x10\x02\
    \x12\x08\n\x04H265\x10\x03\x12\x07\n\x03VP8\x10\x04\x12\x07\n\x03AV1\x10\
    \x05\"\xfa\x07\n\rOptionMessage\x126\n\rimage_quality\x18\x01\x20\x01(\
    \x0e2\x11.hbb.ImageQualityR\x0cimageQuality\x12R\n\x16lock_after_session\
    _end\x18\x02\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x13lockAfte\
    rSessionEnd\x12K\n\x12show_remote_cursor\x18\x03\x20\x01(\x0e2\x1d.hbb.O\
    ptionMessage.BoolOptionR\x10showRemoteCursor\x12@\n\x0cprivacy_mode\x18\
    \x04\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x0bprivacyMode\x12>\
    \n\x0bblock_input\x18\x05\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOption\
    R\nblockInput\x120\n\x14custom_image_quality\x18\x06\x20\x01(\x05R\x12cu\
    stomImageQuality\x12B\n\rdisable_audio\x18\x07\x20\x01(\x0e2\x1d.hbb.Opt\
    ionMessage.BoolOptionR\x0cdisableAudio\x12J\n\x11disable_clipboard\x18\
    \x08\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x10disableClipboard\
    \x12O\n\x14enable_file_transfer\x18\t\x20\x01(\x0e2\x1d.hbb.OptionMessag\
    e.BoolOptionR\x12enableFileTransfer\x12E\n\x12supported_decoding\x18\n\
    \x20\x01(\x0b2\x16.hbb.SupportedDecodingR\x11supportedDecoding\x12\x1d\n\
    \ncustom_fps\x18\x0b\x20\x01(\x05R\tcustomFps\x12H\n\x10disable_keyboard\
    \x18\x0c\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x0fdisableKeybo\
    ard\x12O\n\x14follow_remote_cursor\x18\x0f\x20\x01(\x0e2\x1d.hbb.OptionM\
    essage.BoolOptionR\x12followRemoteCursor\x12O\n\x14follow_remote_window\
    \x18\x10\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x12followRemote\
    Window\")\n\nBoolOption\x12\n\n\x06NotSet\x10\0\x12\x06\n\x02No\x10\x01\
    \x12\x07\n\x03Yes\x10\x02\"\x86\x01\n\tTestDelay\x12\x12\n\x04time\x18\
    \x01\x20\x01(\x03R\x04time\x12\x1f\n\x0bfrom_client\x18\x02\x20\x01(\x08\
    R\nfromClient\x12\x1d\n\nlast_delay\x18\x03\x20\x01(\rR\tlastDelay\x12%\
    \n\x0etarget_bitrate\x18\x04\x20\x01(\rR\rtargetBitrate\"_\n\tPublicKey\
    \x12)\n\x10asymmetric_value\x18\x01\x20\x01(\x0cR\x0fasymmetricValue\x12\
    '\n\x0fsymmetric_value\x18\x02\x20\x01(\x0cR\x0esymmetricValue\"\x1a\n\
    \x08SignedId\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\"J\n\x0bAudioFo\
    rmat\x12\x1f\n\x0bsample_rate\x18\x01\x20\x01(\rR\nsampleRate\x12\x1a\n\
    \x08channels\x18\x02\x20\x01(\rR\x08channels\"\x20\n\nAudioFrame\x12\x12\
    \n\x04data\x18\x01\x20\x01(\x0cR\x04data\"d\n\nMessageBox\x12\x18\n\x07m\
    sgtype\x18\x01\x20\x01(\tR\x07msgtype\x12\x14\n\x05title\x18\x02\x20\x01\
    (\tR\x05title\x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\x12\x12\n\
    \x04link\x18\x04\x20\x01(\tR\x04link\"\xe1\x04\n\x10BackNotification\x12\
    V\n\x12privacy_mode_state\x18\x01\x20\x01(\x0e2&.hbb.BackNotification.Pr\
    ivacyModeStateH\0R\x10privacyModeState\x12S\n\x11block_input_state\x18\
    \x02\x20\x01(\x0e2%.hbb.BackNotification.BlockInputStateH\0R\x0fblockInp\
    utState\x12\x18\n\x07details\x18\x03\x20\x01(\tR\x07details\x12\x19\n\
    \x08impl_key\x18\x04\x20\x01(\tR\x07implKey\"r\n\x0fBlockInputState\x12\
    \x13\n\x0fBlkStateUnknown\x10\0\x12\x12\n\x0eBlkOnSucceeded\x10\x02\x12\
    \x0f\n\x0bBlkOnFailed\x10\x03\x12\x13\n\x0fBlkOffSucceeded\x10\x04\x12\
    \x10\n\x0cBlkOffFailed\x10\x05\"\xed\x01\n\x10PrivacyModeState\x12\x13\n\
    \x0fPrvStateUnknown\x10\0\x12\x10\n\x0cPrvOnByOther\x10\x02\x12\x13\n\
    \x0fPrvNotSupported\x10\x03\x12\x12\n\x0ePrvOnSucceeded\x10\x04\x12\x15\
    \n\x11PrvOnFailedDenied\x10\x05\x12\x15\n\x11PrvOnFailedPlugin\x10\x06\
    \x12\x0f\n\x0bPrvOnFailed\x10\x07\x12\x13\n\x0fPrvOffSucceeded\x10\x08\
    \x12\x10\n\x0cPrvOffByPeer\x10\t\x12\x10\n\x0cPrvOffFailed\x10\n\x12\x11\
    \n\rPrvOffUnknown\x10\x0bB\x07\n\x05union\"S\n\x19ElevationRequestWithLo\
    gon\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\x1a\n\x08p\
    assword\x18\x02\x20\x01(\tR\x08password\"m\n\x10ElevationRequest\x12\x18\
    \n\x06direct\x18\x01\x20\x01(\x08H\0R\x06direct\x126\n\x05logon\x18\x02\
    \x20\x01(\x0b2\x1e.hbb.ElevationRequestWithLogonH\0R\x05logonB\x07\n\x05\
    union\"(\n\x12SwitchSidesRequest\x12\x12\n\x04uuid\x18\x01\x20\x01(\x0cR\
    \x04uuid\"L\n\x13SwitchSidesResponse\x12\x12\n\x04uuid\x18\x01\x20\x01(\
    \x0cR\x04uuid\x12!\n\x02lr\x18\x02\x20\x01(\x0b2\x11.hbb.LoginRequestR\
    \x02lr\"\x0c\n\nSwitchBack\"9\n\rPluginRequest\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x18\n\x07content\x18\x02\x20\x01(\x0cR\x07content\
    \"E\n\rPluginFailure\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x10\n\x03msg\x18\x03\x20\x01(\t\
    R\x03msg\"c\n\x0fWindowsSessions\x12/\n\x08sessions\x18\x01\x20\x03(\x0b\
    2\x13.hbb.WindowsSessionR\x08sessions\x12\x1f\n\x0bcurrent_sid\x18\x02\
    \x20\x01(\rR\ncurrentSid\"5\n\x0cMessageQuery\x12%\n\x0eswitch_display\
    \x18\x01\x20\x01(\x05R\rswitchDisplay\"\xd2\x0e\n\x04Misc\x125\n\x0cchat\
    _message\x18\x04\x20\x01(\x0b2\x10.hbb.ChatMessageH\0R\x0bchatMessage\
    \x12;\n\x0eswitch_display\x18\x05\x20\x01(\x0b2\x12.hbb.SwitchDisplayH\0\
    R\rswitchDisplay\x12>\n\x0fpermission_info\x18\x06\x20\x01(\x0b2\x13.hbb\
    .PermissionInfoH\0R\x0epermissionInfo\x12,\n\x06option\x18\x07\x20\x01(\
    \x0b2\x12.hbb.OptionMessageH\0R\x06option\x125\n\x0caudio_format\x18\x08\
    \x20\x01(\x0b2\x10.hbb.AudioFormatH\0R\x0baudioFormat\x12#\n\x0cclose_re\
    ason\x18\t\x20\x01(\tH\0R\x0bcloseReason\x12%\n\rrefresh_video\x18\n\x20\
    \x01(\x08H\0R\x0crefreshVideo\x12'\n\x0evideo_received\x18\x0c\x20\x01(\
    \x08H\0R\rvideoReceived\x12D\n\x11back_notification\x18\r\x20\x01(\x0b2\
    \x15.hbb.BackNotificationH\0R\x10backNotification\x124\n\x15restart_remo\
    te_device\x18\x0e\x20\x01(\x08H\0R\x13restartRemoteDevice\x12\x12\n\x03u\
    ac\x18\x0f\x20\x01(\x08H\0R\x03uac\x12>\n\x1aforeground_window_elevated\
    \x18\x10\x20\x01(\x08H\0R\x18foregroundWindowElevated\x12#\n\x0cstop_ser\
    vice\x18\x11\x20\x01(\x08H\0R\x0bstopService\x12D\n\x11elevation_request\
    \x18\x12\x20\x01(\x0b2\x15.hbb.ElevationRequestH\0R\x10elevationRequest\
    \x12/\n\x12elevation_response\x18\x13\x20\x01(\tH\0R\x11elevationRespons\
    e\x12:\n\x18portable_service_running\x18\x14\x20\x01(\x08H\0R\x16portabl\
    eServiceRunning\x12K\n\x14switch_sides_request\x18\x15\x20\x01(\x0b2\x17\
    .hbb.SwitchSidesRequestH\0R\x12switchSidesRequest\x122\n\x0bswitch_back\
    \x18\x16\x20\x01(\x0b2\x0f.hbb.SwitchBackH\0R\nswitchBack\x12>\n\x11chan\
    ge_resolution\x18\x18\x20\x01(\x0b2\x0f.hbb.ResolutionH\0R\x10changeReso\
    lution\x12;\n\x0eplugin_request\x18\x19\x20\x01(\x0b2\x12.hbb.PluginRequ\
    estH\0R\rpluginRequest\x12;\n\x0eplugin_failure\x18\x1a\x20\x01(\x0b2\
    \x12.hbb.PluginFailureH\0R\rpluginFailure\x12&\n\x0efull_speed_fps\x18\
    \x1b\x20\x01(\rH\0R\x0cfullSpeedFps\x12(\n\x0fauto_adjust_fps\x18\x1c\
    \x20\x01(\rH\0R\rautoAdjustFps\x122\n\x14client_record_status\x18\x1d\
    \x20\x01(\x08H\0R\x12clientRecordStatus\x12A\n\x10capture_displays\x18\
    \x1e\x20\x01(\x0b2\x14.hbb.CaptureDisplaysH\0R\x0fcaptureDisplays\x124\n\
    \x15refresh_video_display\x18\x1f\x20\x01(\x05H\0R\x13refreshVideoDispla\
    y\x12Q\n\x16toggle_virtual_display\x18\x20\x20\x01(\x0b2\x19.hbb.ToggleV\
    irtualDisplayH\0R\x14toggleVirtualDisplay\x12H\n\x13toggle_privacy_mode\
    \x18!\x20\x01(\x0b2\x16.hbb.TogglePrivacyModeH\0R\x11togglePrivacyMode\
    \x12G\n\x12supported_encoding\x18\"\x20\x01(\x0b2\x16.hbb.SupportedEncod\
    ingH\0R\x11supportedEncoding\x12#\n\x0cselected_sid\x18#\x20\x01(\rH\0R\
    \x0bselectedSid\x12T\n\x19change_display_resolution\x18$\x20\x01(\x0b2\
    \x16.hbb.DisplayResolutionH\0R\x17changeDisplayResolution\x128\n\rmessag\
    e_query\x18%\x20\x01(\x0b2\x11.hbb.MessageQueryH\0R\x0cmessageQuery\x126\
    \n\x16follow_current_display\x18&\x20\x01(\x05H\0R\x14followCurrentDispl\
    ayB\x07\n\x05union\"V\n\x10VoiceCallRequest\x12#\n\rreq_timestamp\x18\
    \x01\x20\x01(\x03R\x0creqTimestamp\x12\x1d\n\nis_connect\x18\x02\x20\x01\
    (\x08R\tisConnect\"y\n\x11VoiceCallResponse\x12\x1a\n\x08accepted\x18\
    \x01\x20\x01(\x08R\x08accepted\x12#\n\rreq_timestamp\x18\x02\x20\x01(\
    \x03R\x0creqTimestamp\x12#\n\rack_timestamp\x18\x03\x20\x01(\x03R\x0cack\
    Timestamp\"\xbb\n\n\x07Message\x12,\n\tsigned_id\x18\x03\x20\x01(\x0b2\r\
    .hbb.SignedIdH\0R\x08signedId\x12/\n\npublic_key\x18\x04\x20\x01(\x0b2\
    \x0e.hbb.PublicKeyH\0R\tpublicKey\x12/\n\ntest_delay\x18\x05\x20\x01(\
    \x0b2\x0e.hbb.TestDelayH\0R\ttestDelay\x122\n\x0bvideo_frame\x18\x06\x20\
    \x01(\x0b2\x0f.hbb.VideoFrameH\0R\nvideoFrame\x128\n\rlogin_request\x18\
    \x07\x20\x01(\x0b2\x11.hbb.LoginRequestH\0R\x0cloginRequest\x12;\n\x0elo\
    gin_response\x18\x08\x20\x01(\x0b2\x12.hbb.LoginResponseH\0R\rloginRespo\
    nse\x12\x1f\n\x04hash\x18\t\x20\x01(\x0b2\t.hbb.HashH\0R\x04hash\x122\n\
    \x0bmouse_event\x18\n\x20\x01(\x0b2\x0f.hbb.MouseEventH\0R\nmouseEvent\
    \x122\n\x0baudio_frame\x18\x0b\x20\x01(\x0b2\x0f.hbb.AudioFrameH\0R\naud\
    ioFrame\x122\n\x0bcursor_data\x18\x0c\x20\x01(\x0b2\x0f.hbb.CursorDataH\
    \0R\ncursorData\x12>\n\x0fcursor_position\x18\r\x20\x01(\x0b2\x13.hbb.Cu\
    rsorPositionH\0R\x0ecursorPosition\x12\x1d\n\tcursor_id\x18\x0e\x20\x01(\
    \x04H\0R\x08cursorId\x12,\n\tkey_event\x18\x0f\x20\x01(\x0b2\r.hbb.KeyEv\
    entH\0R\x08keyEvent\x12.\n\tclipboard\x18\x10\x20\x01(\x0b2\x0e.hbb.Clip\
    boardH\0R\tclipboard\x122\n\x0bfile_action\x18\x11\x20\x01(\x0b2\x0f.hbb\
    .FileActionH\0R\nfileAction\x128\n\rfile_response\x18\x12\x20\x01(\x0b2\
    \x11.hbb.FileResponseH\0R\x0cfileResponse\x12\x1f\n\x04misc\x18\x13\x20\
    \x01(\x0b2\t.hbb.MiscH\0R\x04misc\x12(\n\x07cliprdr\x18\x14\x20\x01(\x0b\
    2\x0c.hbb.CliprdrH\0R\x07cliprdr\x122\n\x0bmessage_box\x18\x15\x20\x01(\
    \x0b2\x0f.hbb.MessageBoxH\0R\nmessageBox\x12N\n\x15switch_sides_response\
    \x18\x16\x20\x01(\x0b2\x18.hbb.SwitchSidesResponseH\0R\x13switchSidesRes\
    ponse\x12E\n\x12voice_call_request\x18\x17\x20\x01(\x0b2\x15.hbb.VoiceCa\
    llRequestH\0R\x10voiceCallRequest\x12H\n\x13voice_call_response\x18\x18\
    \x20\x01(\x0b2\x16.hbb.VoiceCallResponseH\0R\x11voiceCallResponse\x12,\n\
    \tpeer_info\x18\x19\x20\x01(\x0b2\r.hbb.PeerInfoH\0R\x08peerInfo\x12K\n\
    \x14pointer_device_event\x18\x1a\x20\x01(\x0b2\x17.hbb.PointerDeviceEven\
    tH\0R\x12pointerDeviceEvent\x12)\n\x08auth_2fa\x18\x1b\x20\x01(\x0b2\x0c\
    .hbb.Auth2FAH\0R\x07auth2faB\x07\n\x05union*\x1c\n\x06Chroma\x12\x08\n\
    \x04I420\x10\0\x12\x08\n\x04I444\x10\x01*<\n\x0cKeyboardMode\x12\n\n\x06\
    Legacy\x10\0\x12\x07\n\x03Map\x10\x01\x12\r\n\tTranslate\x10\x02\x12\x08\
    \n\x04Auto\x10\x03*\xd4\x07\n\nControlKey\x12\x0b\n\x07Unknown\x10\0\x12\
    \x07\n\x03Alt\x10\x01\x12\r\n\tBackspace\x10\x02\x12\x0c\n\x08CapsLock\
    \x10\x03\x12\x0b\n\x07Control\x10\x04\x12\n\n\x06Delete\x10\x05\x12\r\n\
    \tDownArrow\x10\x06\x12\x07\n\x03End\x10\x07\x12\n\n\x06Escape\x10\x08\
    \x12\x06\n\x02F1\x10\t\x12\x07\n\x03F10\x10\n\x12\x07\n\x03F11\x10\x0b\
    \x12\x07\n\x03F12\x10\x0c\x12\x06\n\x02F2\x10\r\x12\x06\n\x02F3\x10\x0e\
    \x12\x06\n\x02F4\x10\x0f\x12\x06\n\x02F5\x10\x10\x12\x06\n\x02F6\x10\x11\
    \x12\x06\n\x02F7\x10\x12\x12\x06\n\x02F8\x10\x13\x12\x06\n\x02F9\x10\x14\
    \x12\x08\n\x04Home\x10\x15\x12\r\n\tLeftArrow\x10\x16\x12\x08\n\x04Meta\
    \x10\x17\x12\n\n\x06Option\x10\x18\x12\x0c\n\x08PageDown\x10\x19\x12\n\n\
    \x06PageUp\x10\x1a\x12\n\n\x06Return\x10\x1b\x12\x0e\n\nRightArrow\x10\
    \x1c\x12\t\n\x05Shift\x10\x1d\x12\t\n\x05Space\x10\x1e\x12\x07\n\x03Tab\
    \x10\x1f\x12\x0b\n\x07UpArrow\x10\x20\x12\x0b\n\x07Numpad0\x10!\x12\x0b\
    \n\x07Numpad1\x10\"\x12\x0b\n\x07Numpad2\x10#\x12\x0b\n\x07Numpad3\x10$\
    \x12\x0b\n\x07Numpad4\x10%\x12\x0b\n\x07Numpad5\x10&\x12\x0b\n\x07Numpad\
    6\x10'\x12\x0b\n\x07Numpad7\x10(\x12\x0b\n\x07Numpad8\x10)\x12\x0b\n\x07\
    Numpad9\x10*\x12\n\n\x06Cancel\x10+\x12\t\n\x05Clear\x10,\x12\x08\n\x04M\
    enu\x10-\x12\t\n\x05Pause\x10.\x12\x08\n\x04Kana\x10/\x12\n\n\x06Hangul\
    \x100\x12\t\n\x05Junja\x101\x12\t\n\x05Final\x102\x12\t\n\x05Hanja\x103\
    \x12\t\n\x05Kanji\x104\x12\x0b\n\x07Convert\x105\x12\n\n\x06Select\x106\
    \x12\t\n\x05Print\x107\x12\x0b\n\x07Execute\x108\x12\x0c\n\x08Snapshot\
    \x109\x12\n\n\x06Insert\x10:\x12\x08\n\x04Help\x10;\x12\t\n\x05Sleep\x10\
    <\x12\r\n\tSeparator\x10=\x12\n\n\x06Scroll\x10>\x12\x0b\n\x07NumLock\
    \x10?\x12\x08\n\x04RWin\x10@\x12\x08\n\x04Apps\x10A\x12\x0c\n\x08Multipl\
    y\x10B\x12\x07\n\x03Add\x10C\x12\x0c\n\x08Subtract\x10D\x12\x0b\n\x07Dec\
    imal\x10E\x12\n\n\x06Divide\x10F\x12\n\n\x06Equals\x10G\x12\x0f\n\x0bNum\
    padEnter\x10H\x12\n\n\x06RShift\x10I\x12\x0c\n\x08RControl\x10J\x12\x08\
    \n\x04RAlt\x10K\x12\x0e\n\nVolumeMute\x10L\x12\x0c\n\x08VolumeUp\x10M\
    \x12\x0e\n\nVolumeDown\x10N\x12\t\n\x05Power\x10O\x12\x0e\n\nCtrlAltDel\
    \x10d\x12\x0e\n\nLockScreen\x10e*F\n\x08FileType\x12\x07\n\x03Dir\x10\0\
    \x12\x0b\n\x07DirLink\x10\x02\x12\x0c\n\x08DirDrive\x10\x03\x12\x08\n\
    \x04File\x10\x04\x12\x0c\n\x08FileLink\x10\x05*;\n\x0cImageQuality\x12\n\
    \n\x06NotSet\x10\0\x12\x07\n\x03Low\x10\x02\x12\x0c\n\x08Balanced\x10\
    \x03\x12\x08\n\x04Best\x10\x04b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(87);
            messages.push(EncodedVideoFrame::generated_message_descriptor_data());
            messages.push(EncodedVideoFrames::generated_message_descriptor_data());
            messages.push(RGB::generated_message_descriptor_data());
            messages.push(YUV::generated_message_descriptor_data());
            messages.push(VideoFrame::generated_message_descriptor_data());
            messages.push(IdPk::generated_message_descriptor_data());
            messages.push(DisplayInfo::generated_message_descriptor_data());
            messages.push(PortForward::generated_message_descriptor_data());
            messages.push(FileTransfer::generated_message_descriptor_data());
            messages.push(OSLogin::generated_message_descriptor_data());
            messages.push(LoginRequest::generated_message_descriptor_data());
            messages.push(Auth2FA::generated_message_descriptor_data());
            messages.push(ChatMessage::generated_message_descriptor_data());
            messages.push(Features::generated_message_descriptor_data());
            messages.push(CodecAbility::generated_message_descriptor_data());
            messages.push(SupportedEncoding::generated_message_descriptor_data());
            messages.push(PeerInfo::generated_message_descriptor_data());
            messages.push(WindowsSession::generated_message_descriptor_data());
            messages.push(LoginResponse::generated_message_descriptor_data());
            messages.push(TouchScaleUpdate::generated_message_descriptor_data());
            messages.push(TouchPanStart::generated_message_descriptor_data());
            messages.push(TouchPanUpdate::generated_message_descriptor_data());
            messages.push(TouchPanEnd::generated_message_descriptor_data());
            messages.push(TouchEvent::generated_message_descriptor_data());
            messages.push(PointerDeviceEvent::generated_message_descriptor_data());
            messages.push(MouseEvent::generated_message_descriptor_data());
            messages.push(KeyEvent::generated_message_descriptor_data());
            messages.push(CursorData::generated_message_descriptor_data());
            messages.push(CursorPosition::generated_message_descriptor_data());
            messages.push(Hash::generated_message_descriptor_data());
            messages.push(Clipboard::generated_message_descriptor_data());
            messages.push(FileEntry::generated_message_descriptor_data());
            messages.push(FileDirectory::generated_message_descriptor_data());
            messages.push(ReadDir::generated_message_descriptor_data());
            messages.push(ReadAllFiles::generated_message_descriptor_data());
            messages.push(FileAction::generated_message_descriptor_data());
            messages.push(FileTransferCancel::generated_message_descriptor_data());
            messages.push(FileResponse::generated_message_descriptor_data());
            messages.push(FileTransferDigest::generated_message_descriptor_data());
            messages.push(FileTransferBlock::generated_message_descriptor_data());
            messages.push(FileTransferError::generated_message_descriptor_data());
            messages.push(FileTransferSendRequest::generated_message_descriptor_data());
            messages.push(FileTransferSendConfirmRequest::generated_message_descriptor_data());
            messages.push(FileTransferDone::generated_message_descriptor_data());
            messages.push(FileTransferReceiveRequest::generated_message_descriptor_data());
            messages.push(FileRemoveDir::generated_message_descriptor_data());
            messages.push(FileRemoveFile::generated_message_descriptor_data());
            messages.push(FileDirCreate::generated_message_descriptor_data());
            messages.push(CliprdrMonitorReady::generated_message_descriptor_data());
            messages.push(CliprdrFormat::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatList::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatListResponse::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatDataRequest::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatDataResponse::generated_message_descriptor_data());
            messages.push(CliprdrFileContentsRequest::generated_message_descriptor_data());
            messages.push(CliprdrFileContentsResponse::generated_message_descriptor_data());
            messages.push(Cliprdr::generated_message_descriptor_data());
            messages.push(Resolution::generated_message_descriptor_data());
            messages.push(DisplayResolution::generated_message_descriptor_data());
            messages.push(SupportedResolutions::generated_message_descriptor_data());
            messages.push(SwitchDisplay::generated_message_descriptor_data());
            messages.push(CaptureDisplays::generated_message_descriptor_data());
            messages.push(ToggleVirtualDisplay::generated_message_descriptor_data());
            messages.push(TogglePrivacyMode::generated_message_descriptor_data());
            messages.push(PermissionInfo::generated_message_descriptor_data());
            messages.push(SupportedDecoding::generated_message_descriptor_data());
            messages.push(OptionMessage::generated_message_descriptor_data());
            messages.push(TestDelay::generated_message_descriptor_data());
            messages.push(PublicKey::generated_message_descriptor_data());
            messages.push(SignedId::generated_message_descriptor_data());
            messages.push(AudioFormat::generated_message_descriptor_data());
            messages.push(AudioFrame::generated_message_descriptor_data());
            messages.push(MessageBox::generated_message_descriptor_data());
            messages.push(BackNotification::generated_message_descriptor_data());
            messages.push(ElevationRequestWithLogon::generated_message_descriptor_data());
            messages.push(ElevationRequest::generated_message_descriptor_data());
            messages.push(SwitchSidesRequest::generated_message_descriptor_data());
            messages.push(SwitchSidesResponse::generated_message_descriptor_data());
            messages.push(SwitchBack::generated_message_descriptor_data());
            messages.push(PluginRequest::generated_message_descriptor_data());
            messages.push(PluginFailure::generated_message_descriptor_data());
            messages.push(WindowsSessions::generated_message_descriptor_data());
            messages.push(MessageQuery::generated_message_descriptor_data());
            messages.push(Misc::generated_message_descriptor_data());
            messages.push(VoiceCallRequest::generated_message_descriptor_data());
            messages.push(VoiceCallResponse::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(Chroma::generated_enum_descriptor_data());
            enums.push(KeyboardMode::generated_enum_descriptor_data());
            enums.push(ControlKey::generated_enum_descriptor_data());
            enums.push(FileType::generated_enum_descriptor_data());
            enums.push(ImageQuality::generated_enum_descriptor_data());
            enums.push(permission_info::Permission::generated_enum_descriptor_data());
            enums.push(supported_decoding::PreferCodec::generated_enum_descriptor_data());
            enums.push(option_message::BoolOption::generated_enum_descriptor_data());
            enums.push(back_notification::BlockInputState::generated_enum_descriptor_data());
            enums.push(back_notification::PrivacyModeState::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
